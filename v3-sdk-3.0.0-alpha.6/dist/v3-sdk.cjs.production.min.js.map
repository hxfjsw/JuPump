{"version":3,"file":"v3-sdk.cjs.production.min.js","sources":["../src/constants.ts","../node_modules/regenerator-runtime/runtime.js","../src/internalConstants.ts","../src/utils/computePoolAddress.ts","../src/utils/liquidityMath.ts","../src/utils/fullMath.ts","../src/utils/sqrtPriceMath.ts","../src/utils/swapMath.ts","../src/utils/mostSignificantBit.ts","../src/utils/tickMath.ts","../src/entities/tickDataProvider.ts","../src/utils/isSorted.ts","../src/utils/tickList.ts","../src/utils/calldata.ts","../src/utils/encodeRouteToPath.ts","../src/utils/encodeSqrtRatioX96.ts","../src/utils/maxLiquidityForAmounts.ts","../src/utils/priceTickConversions.ts","../src/entities/tick.ts","../src/entities/tickListDataProvider.ts","../src/entities/pool.ts","../src/entities/position.ts","../src/entities/route.ts","../src/entities/trade.ts","../src/selfPermit.ts","../src/nonfungiblePositionManager.ts","../src/swapRouter.ts","../src/utils/nearestUsableTick.ts"],"sourcesContent":["export const FACTORY_ADDRESS = '0xA1e393178DDFD63af56cf0BfA759A6a85606558c'\r\n\r\nexport const ADDRESS_ZERO = '0x0000000000000000000000000000000000000000'\r\n\r\nexport const POOL_INIT_CODE_HASH = '0xd63426cf28b23363557856eaa7e085559e81e6b7794066479952bda868617297'\r\n\r\n/**\r\n * The default factory enabled fee amounts, denominated in hundredths of bips.\r\n */\r\nexport enum FeeAmount {\r\n  LOW = 500,\r\n  MEDIUM = 3000,\r\n  HIGH = 10000\r\n}\r\n\r\n/**\r\n * The default factory tick spacings by fee amount.\r\n */\r\nexport const TICK_SPACINGS: { [amount in FeeAmount]: number } = {\r\n  [FeeAmount.LOW]: 10,\r\n  [FeeAmount.MEDIUM]: 60,\r\n  [FeeAmount.HIGH]: 200\r\n}\r\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n","import JSBI from 'jsbi'\n\n// constants used internally but not expected to be used externally\nexport const NEGATIVE_ONE = JSBI.BigInt(-1)\nexport const ZERO = JSBI.BigInt(0)\nexport const ONE = JSBI.BigInt(1)\n\n// used in liquidity amount math\nexport const Q96 = JSBI.exponentiate(JSBI.BigInt(2), JSBI.BigInt(96))\nexport const Q192 = JSBI.exponentiate(Q96, JSBI.BigInt(2))\n","import { defaultAbiCoder } from '@ethersproject/abi'\r\nimport { getCreate2Address } from '@ethersproject/address'\r\nimport { keccak256 } from '@ethersproject/solidity'\r\nimport { Token } from '@uniswap/sdk-core'\r\nimport { FeeAmount, POOL_INIT_CODE_HASH } from '../constants'\r\n\r\nexport function computePoolAddress({\r\n  factoryAddress,\r\n  tokenA,\r\n  tokenB,\r\n  fee\r\n}: {\r\n  factoryAddress: string\r\n  tokenA: Token\r\n  tokenB: Token\r\n  fee: FeeAmount\r\n}): string {\r\n  const [token0, token1] = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA] // does safety checks\r\n  return getCreate2Address(\r\n    factoryAddress,\r\n    keccak256(\r\n      ['bytes'],\r\n      [defaultAbiCoder.encode(['address', 'address', 'uint24'], [token0.address, token1.address, fee])]\r\n    ),\r\n    POOL_INIT_CODE_HASH\r\n  )\r\n}\r\n\r\n// const MTK = new Token(2100000,\"0x1a180690efd9Aa55550178c548A5548310D500e6\",18)\r\n// const WETH9 = new Token(2100000,\"0x4d1b49b424afd7075d3c063addf97d5575e1c7e2\",18)\r\n// console.log(\"computePoolAddress\",computePoolAddress({factoryAddress:\"0xa8eDB7A6922113968896F82302B0E803216E9986\",tokenA:MTK,tokenB:WETH9,fee:FeeAmount.HIGH}))","import JSBI from 'jsbi'\nimport { NEGATIVE_ONE, ZERO } from '../internalConstants'\n\nexport abstract class LiquidityMath {\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n\n  public static addDelta(x: JSBI, y: JSBI): JSBI {\n    if (JSBI.lessThan(y, ZERO)) {\n      return JSBI.subtract(x, JSBI.multiply(y, NEGATIVE_ONE))\n    } else {\n      return JSBI.add(x, y)\n    }\n  }\n}\n","import JSBI from 'jsbi'\nimport { ONE, ZERO } from '../internalConstants'\n\nexport abstract class FullMath {\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n\n  public static mulDivRoundingUp(a: JSBI, b: JSBI, denominator: JSBI): JSBI {\n    const product = JSBI.multiply(a, b)\n    let result = JSBI.divide(product, denominator)\n    if (JSBI.notEqual(JSBI.remainder(product, denominator), ZERO)) result = JSBI.add(result, ONE)\n    return result\n  }\n}\n","import { MaxUint256 } from '@uniswap/sdk-core'\nimport JSBI from 'jsbi'\nimport invariant from 'tiny-invariant'\nimport { ONE, ZERO, Q96 } from '../internalConstants'\nimport { FullMath } from './fullMath'\n\nconst MaxUint160 = JSBI.subtract(JSBI.exponentiate(JSBI.BigInt(2), JSBI.BigInt(160)), ONE)\n\nfunction multiplyIn256(x: JSBI, y: JSBI): JSBI {\n  const product = JSBI.multiply(x, y)\n  return JSBI.bitwiseAnd(product, MaxUint256)\n}\n\nfunction addIn256(x: JSBI, y: JSBI): JSBI {\n  const sum = JSBI.add(x, y)\n  return JSBI.bitwiseAnd(sum, MaxUint256)\n}\n\nexport abstract class SqrtPriceMath {\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n\n  public static getAmount0Delta(sqrtRatioAX96: JSBI, sqrtRatioBX96: JSBI, liquidity: JSBI, roundUp: boolean): JSBI {\n    if (JSBI.greaterThan(sqrtRatioAX96, sqrtRatioBX96)) {\n      ;[sqrtRatioAX96, sqrtRatioBX96] = [sqrtRatioBX96, sqrtRatioAX96]\n    }\n\n    const numerator1 = JSBI.leftShift(liquidity, JSBI.BigInt(96))\n    const numerator2 = JSBI.subtract(sqrtRatioBX96, sqrtRatioAX96)\n\n    return roundUp\n      ? FullMath.mulDivRoundingUp(FullMath.mulDivRoundingUp(numerator1, numerator2, sqrtRatioBX96), ONE, sqrtRatioAX96)\n      : JSBI.divide(JSBI.divide(JSBI.multiply(numerator1, numerator2), sqrtRatioBX96), sqrtRatioAX96)\n  }\n\n  public static getAmount1Delta(sqrtRatioAX96: JSBI, sqrtRatioBX96: JSBI, liquidity: JSBI, roundUp: boolean): JSBI {\n    if (JSBI.greaterThan(sqrtRatioAX96, sqrtRatioBX96)) {\n      ;[sqrtRatioAX96, sqrtRatioBX96] = [sqrtRatioBX96, sqrtRatioAX96]\n    }\n\n    return roundUp\n      ? FullMath.mulDivRoundingUp(liquidity, JSBI.subtract(sqrtRatioBX96, sqrtRatioAX96), Q96)\n      : JSBI.divide(JSBI.multiply(liquidity, JSBI.subtract(sqrtRatioBX96, sqrtRatioAX96)), Q96)\n  }\n\n  public static getNextSqrtPriceFromInput(sqrtPX96: JSBI, liquidity: JSBI, amountIn: JSBI, zeroForOne: boolean): JSBI {\n    invariant(JSBI.greaterThan(sqrtPX96, ZERO))\n    invariant(JSBI.greaterThan(liquidity, ZERO))\n\n    return zeroForOne\n      ? this.getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountIn, true)\n      : this.getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountIn, true)\n  }\n\n  public static getNextSqrtPriceFromOutput(\n    sqrtPX96: JSBI,\n    liquidity: JSBI,\n    amountOut: JSBI,\n    zeroForOne: boolean\n  ): JSBI {\n    invariant(JSBI.greaterThan(sqrtPX96, ZERO))\n    invariant(JSBI.greaterThan(liquidity, ZERO))\n\n    return zeroForOne\n      ? this.getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountOut, false)\n      : this.getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountOut, false)\n  }\n\n  private static getNextSqrtPriceFromAmount0RoundingUp(\n    sqrtPX96: JSBI,\n    liquidity: JSBI,\n    amount: JSBI,\n    add: boolean\n  ): JSBI {\n    if (JSBI.equal(amount, ZERO)) return sqrtPX96\n    const numerator1 = JSBI.leftShift(liquidity, JSBI.BigInt(96))\n\n    if (add) {\n      let product = multiplyIn256(amount, sqrtPX96)\n      if (JSBI.equal(JSBI.divide(product, amount), sqrtPX96)) {\n        const denominator = addIn256(numerator1, product)\n        if (JSBI.greaterThanOrEqual(denominator, numerator1)) {\n          return FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator)\n        }\n      }\n\n      return FullMath.mulDivRoundingUp(numerator1, ONE, JSBI.add(JSBI.divide(numerator1, sqrtPX96), amount))\n    } else {\n      let product = multiplyIn256(amount, sqrtPX96)\n\n      invariant(JSBI.equal(JSBI.divide(product, amount), sqrtPX96))\n      invariant(JSBI.greaterThan(numerator1, product))\n      const denominator = JSBI.subtract(numerator1, product)\n      return FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator)\n    }\n  }\n\n  private static getNextSqrtPriceFromAmount1RoundingDown(\n    sqrtPX96: JSBI,\n    liquidity: JSBI,\n    amount: JSBI,\n    add: boolean\n  ): JSBI {\n    if (add) {\n      const quotient = JSBI.lessThanOrEqual(amount, MaxUint160)\n        ? JSBI.divide(JSBI.leftShift(amount, JSBI.BigInt(96)), liquidity)\n        : JSBI.divide(JSBI.multiply(amount, Q96), liquidity)\n\n      return JSBI.add(sqrtPX96, quotient)\n    } else {\n      const quotient = FullMath.mulDivRoundingUp(amount, Q96, liquidity)\n\n      invariant(JSBI.greaterThan(sqrtPX96, quotient))\n      return JSBI.subtract(sqrtPX96, quotient)\n    }\n  }\n}\n","import JSBI from 'jsbi'\nimport { FeeAmount } from '../constants'\nimport { NEGATIVE_ONE, ZERO } from '../internalConstants'\nimport { FullMath } from './fullMath'\nimport { SqrtPriceMath } from './sqrtPriceMath'\n\nconst MAX_FEE = JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(6))\n\nexport abstract class SwapMath {\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n\n  public static computeSwapStep(\n    sqrtRatioCurrentX96: JSBI,\n    sqrtRatioTargetX96: JSBI,\n    liquidity: JSBI,\n    amountRemaining: JSBI,\n    feePips: FeeAmount\n  ): [JSBI, JSBI, JSBI, JSBI] {\n    const returnValues: Partial<{\n      sqrtRatioNextX96: JSBI\n      amountIn: JSBI\n      amountOut: JSBI\n      feeAmount: JSBI\n    }> = {}\n\n    const zeroForOne = JSBI.greaterThanOrEqual(sqrtRatioCurrentX96, sqrtRatioTargetX96)\n    const exactIn = JSBI.greaterThanOrEqual(amountRemaining, ZERO)\n\n    if (exactIn) {\n      const amountRemainingLessFee = JSBI.divide(\n        JSBI.multiply(amountRemaining, JSBI.subtract(MAX_FEE, JSBI.BigInt(feePips))),\n        MAX_FEE\n      )\n      returnValues.amountIn = zeroForOne\n        ? SqrtPriceMath.getAmount0Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, true)\n        : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, true)\n      if (JSBI.greaterThanOrEqual(amountRemainingLessFee, returnValues.amountIn!)) {\n        returnValues.sqrtRatioNextX96 = sqrtRatioTargetX96\n      } else {\n        returnValues.sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromInput(\n          sqrtRatioCurrentX96,\n          liquidity,\n          amountRemainingLessFee,\n          zeroForOne\n        )\n      }\n    } else {\n      returnValues.amountOut = zeroForOne\n        ? SqrtPriceMath.getAmount1Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, false)\n        : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, false)\n      if (JSBI.greaterThanOrEqual(JSBI.multiply(amountRemaining, NEGATIVE_ONE), returnValues.amountOut)) {\n        returnValues.sqrtRatioNextX96 = sqrtRatioTargetX96\n      } else {\n        returnValues.sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromOutput(\n          sqrtRatioCurrentX96,\n          liquidity,\n          JSBI.multiply(amountRemaining, NEGATIVE_ONE),\n          zeroForOne\n        )\n      }\n    }\n\n    const max = JSBI.equal(sqrtRatioTargetX96, returnValues.sqrtRatioNextX96)\n\n    if (zeroForOne) {\n      returnValues.amountIn =\n        max && exactIn\n          ? returnValues.amountIn\n          : SqrtPriceMath.getAmount0Delta(returnValues.sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, true)\n      returnValues.amountOut =\n        max && !exactIn\n          ? returnValues.amountOut\n          : SqrtPriceMath.getAmount1Delta(returnValues.sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, false)\n    } else {\n      returnValues.amountIn =\n        max && exactIn\n          ? returnValues.amountIn\n          : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, returnValues.sqrtRatioNextX96, liquidity, true)\n      returnValues.amountOut =\n        max && !exactIn\n          ? returnValues.amountOut\n          : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, returnValues.sqrtRatioNextX96, liquidity, false)\n    }\n\n    if (!exactIn && JSBI.greaterThan(returnValues.amountOut!, JSBI.multiply(amountRemaining, NEGATIVE_ONE))) {\n      returnValues.amountOut = JSBI.multiply(amountRemaining, NEGATIVE_ONE)\n    }\n\n    if (exactIn && JSBI.notEqual(returnValues.sqrtRatioNextX96, sqrtRatioTargetX96)) {\n      // we didn't reach the target, so take the remainder of the maximum input as fee\n      returnValues.feeAmount = JSBI.subtract(amountRemaining, returnValues.amountIn!)\n    } else {\n      returnValues.feeAmount = FullMath.mulDivRoundingUp(\n        returnValues.amountIn!,\n        JSBI.BigInt(feePips),\n        JSBI.subtract(MAX_FEE, JSBI.BigInt(feePips))\n      )\n    }\n\n    return [returnValues.sqrtRatioNextX96!, returnValues.amountIn!, returnValues.amountOut!, returnValues.feeAmount!]\n  }\n}\n","import { MaxUint256 } from '@uniswap/sdk-core'\nimport JSBI from 'jsbi'\nimport invariant from 'tiny-invariant'\nimport { ZERO } from '../internalConstants'\n\nconst TWO = JSBI.BigInt(2)\nconst POWERS_OF_2 = [128, 64, 32, 16, 8, 4, 2, 1].map((pow: number): [number, JSBI] => [\n  pow,\n  JSBI.exponentiate(TWO, JSBI.BigInt(pow))\n])\n\nexport function mostSignificantBit(x: JSBI): number {\n  invariant(JSBI.greaterThan(x, ZERO), 'ZERO')\n  invariant(JSBI.lessThanOrEqual(x, MaxUint256), 'MAX')\n\n  let msb: number = 0\n  for (const [power, min] of POWERS_OF_2) {\n    if (JSBI.greaterThanOrEqual(x, min)) {\n      x = JSBI.signedRightShift(x, JSBI.BigInt(power))\n      msb += power\n    }\n  }\n  return msb\n}\n","import { MaxUint256 } from '@uniswap/sdk-core'\nimport JSBI from 'jsbi'\nimport invariant from 'tiny-invariant'\nimport { ONE, ZERO } from '../internalConstants'\nimport { mostSignificantBit } from './mostSignificantBit'\n\nfunction mulShift(val: JSBI, mulBy: string): JSBI {\n  return JSBI.signedRightShift(JSBI.multiply(val, JSBI.BigInt(mulBy)), JSBI.BigInt(128))\n}\n\nconst Q32 = JSBI.exponentiate(JSBI.BigInt(2), JSBI.BigInt(32))\n\nexport abstract class TickMath {\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n\n  /**\n   * The minimum tick that can be used on any pool.\n   */\n  public static MIN_TICK: number = -887272\n  /**\n   * The maximum tick that can be used on any pool.\n   */\n  public static MAX_TICK: number = -TickMath.MIN_TICK\n\n  /**\n   * The sqrt ratio corresponding to the minimum tick that could be used on any pool.\n   */\n  public static MIN_SQRT_RATIO: JSBI = JSBI.BigInt('4295128739')\n  /**\n   * The sqrt ratio corresponding to the maximum tick that could be used on any pool.\n   */\n  public static MAX_SQRT_RATIO: JSBI = JSBI.BigInt('1461446703485210103287273052203988822378723970342')\n\n  /**\n   * Returns the sqrt ratio as a Q64.96 for the given tick. The sqrt ratio is computed as sqrt(1.0001)^tick\n   * @param tick the tick for which to compute the sqrt ratio\n   */\n  public static getSqrtRatioAtTick(tick: number): JSBI {\n    invariant(tick >= TickMath.MIN_TICK && tick <= TickMath.MAX_TICK && Number.isInteger(tick), 'TICK')\n    const absTick: number = tick < 0 ? tick * -1 : tick\n\n    let ratio: JSBI =\n      (absTick & 0x1) != 0\n        ? JSBI.BigInt('0xfffcb933bd6fad37aa2d162d1a594001')\n        : JSBI.BigInt('0x100000000000000000000000000000000')\n    if ((absTick & 0x2) != 0) ratio = mulShift(ratio, '0xfff97272373d413259a46990580e213a')\n    if ((absTick & 0x4) != 0) ratio = mulShift(ratio, '0xfff2e50f5f656932ef12357cf3c7fdcc')\n    if ((absTick & 0x8) != 0) ratio = mulShift(ratio, '0xffe5caca7e10e4e61c3624eaa0941cd0')\n    if ((absTick & 0x10) != 0) ratio = mulShift(ratio, '0xffcb9843d60f6159c9db58835c926644')\n    if ((absTick & 0x20) != 0) ratio = mulShift(ratio, '0xff973b41fa98c081472e6896dfb254c0')\n    if ((absTick & 0x40) != 0) ratio = mulShift(ratio, '0xff2ea16466c96a3843ec78b326b52861')\n    if ((absTick & 0x80) != 0) ratio = mulShift(ratio, '0xfe5dee046a99a2a811c461f1969c3053')\n    if ((absTick & 0x100) != 0) ratio = mulShift(ratio, '0xfcbe86c7900a88aedcffc83b479aa3a4')\n    if ((absTick & 0x200) != 0) ratio = mulShift(ratio, '0xf987a7253ac413176f2b074cf7815e54')\n    if ((absTick & 0x400) != 0) ratio = mulShift(ratio, '0xf3392b0822b70005940c7a398e4b70f3')\n    if ((absTick & 0x800) != 0) ratio = mulShift(ratio, '0xe7159475a2c29b7443b29c7fa6e889d9')\n    if ((absTick & 0x1000) != 0) ratio = mulShift(ratio, '0xd097f3bdfd2022b8845ad8f792aa5825')\n    if ((absTick & 0x2000) != 0) ratio = mulShift(ratio, '0xa9f746462d870fdf8a65dc1f90e061e5')\n    if ((absTick & 0x4000) != 0) ratio = mulShift(ratio, '0x70d869a156d2a1b890bb3df62baf32f7')\n    if ((absTick & 0x8000) != 0) ratio = mulShift(ratio, '0x31be135f97d08fd981231505542fcfa6')\n    if ((absTick & 0x10000) != 0) ratio = mulShift(ratio, '0x9aa508b5b7a84e1c677de54f3e99bc9')\n    if ((absTick & 0x20000) != 0) ratio = mulShift(ratio, '0x5d6af8dedb81196699c329225ee604')\n    if ((absTick & 0x40000) != 0) ratio = mulShift(ratio, '0x2216e584f5fa1ea926041bedfe98')\n    if ((absTick & 0x80000) != 0) ratio = mulShift(ratio, '0x48a170391f7dc42444e8fa2')\n\n    if (tick > 0) ratio = JSBI.divide(MaxUint256, ratio)\n\n    // back to Q96\n    return JSBI.greaterThan(JSBI.remainder(ratio, Q32), ZERO)\n      ? JSBI.add(JSBI.divide(ratio, Q32), ONE)\n      : JSBI.divide(ratio, Q32)\n  }\n\n  /**\n   * Returns the tick corresponding to a given sqrt ratio, s.t. #getSqrtRatioAtTick(tick) <= sqrtRatioX96\n   * and #getSqrtRatioAtTick(tick + 1) > sqrtRatioX96\n   * @param sqrtRatioX96 the sqrt ratio as a Q64.96 for which to compute the tick\n   */\n  public static getTickAtSqrtRatio(sqrtRatioX96: JSBI): number {\n    invariant(\n      JSBI.greaterThanOrEqual(sqrtRatioX96, TickMath.MIN_SQRT_RATIO) &&\n        JSBI.lessThan(sqrtRatioX96, TickMath.MAX_SQRT_RATIO),\n      'SQRT_RATIO'\n    )\n\n    const sqrtRatioX128 = JSBI.leftShift(sqrtRatioX96, JSBI.BigInt(32))\n\n    const msb = mostSignificantBit(sqrtRatioX128)\n\n    let r: JSBI\n    if (JSBI.greaterThanOrEqual(JSBI.BigInt(msb), JSBI.BigInt(128))) {\n      r = JSBI.signedRightShift(sqrtRatioX128, JSBI.BigInt(msb - 127))\n    } else {\n      r = JSBI.leftShift(sqrtRatioX128, JSBI.BigInt(127 - msb))\n    }\n\n    let log_2: JSBI = JSBI.leftShift(JSBI.subtract(JSBI.BigInt(msb), JSBI.BigInt(128)), JSBI.BigInt(64))\n\n    for (let i = 0; i < 14; i++) {\n      r = JSBI.signedRightShift(JSBI.multiply(r, r), JSBI.BigInt(127))\n      const f = JSBI.signedRightShift(r, JSBI.BigInt(128))\n      log_2 = JSBI.bitwiseOr(log_2, JSBI.leftShift(f, JSBI.BigInt(63 - i)))\n      r = JSBI.signedRightShift(r, f)\n    }\n\n    const log_sqrt10001 = JSBI.multiply(log_2, JSBI.BigInt('255738958999603826347141'))\n\n    const tickLow = JSBI.toNumber(\n      JSBI.signedRightShift(\n        JSBI.subtract(log_sqrt10001, JSBI.BigInt('3402992956809132418596140100660247210')),\n        JSBI.BigInt(128)\n      )\n    )\n    const tickHigh = JSBI.toNumber(\n      JSBI.signedRightShift(\n        JSBI.add(log_sqrt10001, JSBI.BigInt('291339464771989622907027621153398088495')),\n        JSBI.BigInt(128)\n      )\n    )\n\n    return tickLow === tickHigh\n      ? tickLow\n      : JSBI.lessThanOrEqual(TickMath.getSqrtRatioAtTick(tickHigh), sqrtRatioX96)\n      ? tickHigh\n      : tickLow\n  }\n}\n","import { BigintIsh } from '@uniswap/sdk-core'\n\n/**\n * Provides information about ticks\n */\nexport interface TickDataProvider {\n  /**\n   * Return information corresponding to a specific tick\n   * @param tick the tick to load\n   */\n  getTick(tick: number): Promise<{ liquidityNet: BigintIsh }>\n\n  /**\n   * Return the next tick that is initialized within a single word\n   * @param tick the current tick\n   * @param lte whether the next tick should be lte the current tick\n   * @param tickSpacing the tick spacing of the pool\n   */\n  nextInitializedTickWithinOneWord(tick: number, lte: boolean, tickSpacing: number): Promise<[number, boolean]>\n}\n\n/**\n * This tick data provider does not know how to fetch any tick data. It throws whenever it is required. Useful if you\n * do not need to load tick data for your use case.\n */\nexport class NoTickDataProvider implements TickDataProvider {\n  private static ERROR_MESSAGE = 'No tick data provider was given'\n  async getTick(_tick: number): Promise<{ liquidityNet: BigintIsh }> {\n    throw new Error(NoTickDataProvider.ERROR_MESSAGE)\n  }\n\n  async nextInitializedTickWithinOneWord(\n    _tick: number,\n    _lte: boolean,\n    _tickSpacing: number\n  ): Promise<[number, boolean]> {\n    throw new Error(NoTickDataProvider.ERROR_MESSAGE)\n  }\n}\n","export function isSorted<T>(list: Array<T>, comparator: (a: T, b: T) => number): boolean {\n  for (let i = 0; i < list.length - 1; i++) {\n    if (comparator(list[i], list[i + 1]) > 0) {\n      return false\n    }\n  }\n  return true\n}\n","import JSBI from 'jsbi'\nimport invariant from 'tiny-invariant'\nimport { ZERO } from '../internalConstants'\nimport { isSorted } from './isSorted'\nimport { Tick } from '../entities/tick'\n\nfunction tickComparator(a: Tick, b: Tick) {\n  return a.index - b.index\n}\n\n/**\n * Utility methods for interacting with sorted lists of ticks\n */\nexport abstract class TickList {\n  /**\n   * Cannot be constructed\n   */\n  private constructor() {}\n\n  public static validateList(ticks: Tick[], tickSpacing: number) {\n    invariant(tickSpacing > 0, 'TICK_SPACING_NONZERO')\n    // ensure ticks are spaced appropriately\n    invariant(\n      ticks.every(({ index }) => index % tickSpacing === 0),\n      'TICK_SPACING'\n    )\n\n    // ensure tick liquidity deltas sum to 0\n    invariant(\n      JSBI.equal(\n        ticks.reduce((accumulator, { liquidityNet }) => JSBI.add(accumulator, liquidityNet), ZERO),\n        ZERO\n      ),\n      'ZERO_NET'\n    )\n\n    invariant(isSorted(ticks, tickComparator), 'SORTED')\n  }\n\n  public static isBelowSmallest(ticks: readonly Tick[], tick: number): boolean {\n    invariant(ticks.length > 0, 'LENGTH')\n    return tick < ticks[0].index\n  }\n\n  public static isAtOrAboveLargest(ticks: readonly Tick[], tick: number): boolean {\n    invariant(ticks.length > 0, 'LENGTH')\n    return tick >= ticks[ticks.length - 1].index\n  }\n\n  public static getTick(ticks: readonly Tick[], index: number): Tick {\n    const tick = ticks[this.binarySearch(ticks, index)]\n    invariant(tick.index === index, 'NOT_CONTAINED')\n    return tick\n  }\n\n  /**\n   * Finds the largest tick in the list of ticks that is less than or equal to tick\n   * @param ticks list of ticks\n   * @param tick tick to find the largest tick that is less than or equal to tick\n   * @private\n   */\n  private static binarySearch(ticks: readonly Tick[], tick: number): number {\n    invariant(!this.isBelowSmallest(ticks, tick), 'BELOW_SMALLEST')\n\n    let l = 0\n    let r = ticks.length - 1\n    let i\n    while (true) {\n      i = Math.floor((l + r) / 2)\n\n      if (ticks[i].index <= tick && (i === ticks.length - 1 || ticks[i + 1].index > tick)) {\n        return i\n      }\n\n      if (ticks[i].index < tick) {\n        l = i + 1\n      } else {\n        r = i - 1\n      }\n    }\n  }\n\n  public static nextInitializedTick(ticks: readonly Tick[], tick: number, lte: boolean): Tick {\n    if (lte) {\n      invariant(!TickList.isBelowSmallest(ticks, tick), 'BELOW_SMALLEST')\n      if (TickList.isAtOrAboveLargest(ticks, tick)) {\n        return ticks[ticks.length - 1]\n      }\n      const index = this.binarySearch(ticks, tick)\n      return ticks[index]\n    } else {\n      invariant(!this.isAtOrAboveLargest(ticks, tick), 'AT_OR_ABOVE_LARGEST')\n      if (this.isBelowSmallest(ticks, tick)) {\n        return ticks[0]\n      }\n      const index = this.binarySearch(ticks, tick)\n      return ticks[index + 1]\n    }\n  }\n\n  public static nextInitializedTickWithinOneWord(\n    ticks: readonly Tick[],\n    tick: number,\n    lte: boolean,\n    tickSpacing: number\n  ): [number, boolean] {\n    const compressed = Math.floor(tick / tickSpacing) // matches rounding in the code\n\n    if (lte) {\n      const wordPos = compressed >> 8\n      const minimum = (wordPos << 8) * tickSpacing\n\n      if (TickList.isBelowSmallest(ticks, tick)) {\n        return [minimum, false]\n      }\n\n      const index = TickList.nextInitializedTick(ticks, tick, lte).index\n      const nextInitializedTick = Math.max(minimum, index)\n      return [nextInitializedTick, nextInitializedTick === index]\n    } else {\n      const wordPos = (compressed + 1) >> 8\n      const maximum = ((wordPos + 1) << 8) * tickSpacing - 1\n\n      if (this.isAtOrAboveLargest(ticks, tick)) {\n        return [maximum, false]\n      }\n\n      const index = this.nextInitializedTick(ticks, tick, lte).index\n      const nextInitializedTick = Math.min(maximum, index)\n      return [nextInitializedTick, nextInitializedTick === index]\n    }\n  }\n}\n","import { BigintIsh } from '@uniswap/sdk-core'\nimport JSBI from 'jsbi'\n\n/**\n * Generated method parameters for executing a call.\n */\nexport interface MethodParameters {\n  /**\n   * The hex encoded calldata to perform the given operation\n   */\n  calldata: string\n  /**\n   * The amount of ether (wei) to send in hex.\n   */\n  value: string\n}\n\nexport function toHex(bigintIsh: BigintIsh) {\n  const bigInt = JSBI.BigInt(bigintIsh)\n  let hex = bigInt.toString(16)\n  if (hex.length % 2 !== 0) {\n    hex = `0${hex}`\n  }\n  return `0x${hex}`\n}\n","import { pack } from '@ethersproject/solidity'\nimport { Currency, Token ,ChainId,WETH9} from '@uniswap/sdk-core'\nimport { Pool } from '../entities/pool'\nimport { Route } from '../entities/route'\n\nfunction wrappedCurrency(currency: Currency, chainId: ChainId): Token {\n  if (currency.isToken) {\n    // invariant(currency.chainId === chainId, 'CHAIN_ID')\n    return currency\n  }\n  if (chainId === 210000) {\n    const WJU = new Token(210000, '0x4d1b49b424afd7075d3c063addf97d5575e1c7e2', 18, 'WJU', 'Wrapped JU')\n    return WJU\n  }\n  if (currency.isEther) return WETH9[chainId]\n  throw new Error('CURRENCY')\n}\n\n/**\n * Converts a route to a hex encoded path\n * @param route the v3 path to convert to an encoded path\n * @param exactOutput whether the route should be encoded in reverse, for making exact output swaps\n */\nexport function encodeRouteToPath(route: Route<Currency, Currency>, exactOutput: boolean): string {\n  const firstInputToken: Token = wrappedCurrency(route.input, route.chainId)\n\n  const { path, types } = route.pools.reduce(\n    (\n      { inputToken, path, types }: { inputToken: Token; path: (string | number)[]; types: string[] },\n      pool: Pool,\n      index\n    ): { inputToken: Token; path: (string | number)[]; types: string[] } => {\n      const outputToken: Token = pool.token0.equals(inputToken) ? pool.token1 : pool.token0\n      if (index === 0) {\n        return {\n          inputToken: outputToken,\n          types: ['address', 'uint24', 'address'],\n          path: [inputToken.address, pool.fee, outputToken.address]\n        }\n      } else {\n        return {\n          inputToken: outputToken,\n          types: [...types, 'uint24', 'address'],\n          path: [...path, pool.fee, outputToken.address]\n        }\n      }\n    },\n    { inputToken: firstInputToken, path: [], types: [] }\n  )\n\n  return exactOutput ? pack(types.reverse(), path.reverse()) : pack(types, path)\n}\n","import JSBI from 'jsbi'\nimport { BigintIsh, sqrt } from '@uniswap/sdk-core'\n\n/**\n * Returns the sqrt ratio as a Q64.96 corresponding to a given ratio of amount1 and amount0\n * @param amount1 the numerator amount, i.e. amount of token1\n * @param amount0 the denominator amount, i.en amount of token0\n */\nexport function encodeSqrtRatioX96(amount1: BigintIsh, amount0: BigintIsh): JSBI {\n  const numerator = JSBI.leftShift(JSBI.BigInt(amount1), JSBI.BigInt(192))\n  const denominator = JSBI.BigInt(amount0)\n  const ratioX192 = JSBI.divide(numerator, denominator)\n  return sqrt(ratioX192)\n}\n","import { BigintIsh } from '@uniswap/sdk-core'\nimport JSBI from 'jsbi'\nimport { Q96 } from '../internalConstants'\n\nfunction maxLiquidityForAmount0Imprecise(sqrtRatioAX96: JSBI, sqrtRatioBX96: JSBI, amount0: BigintIsh): JSBI {\n  if (JSBI.greaterThan(sqrtRatioAX96, sqrtRatioBX96)) {\n    ;[sqrtRatioAX96, sqrtRatioBX96] = [sqrtRatioBX96, sqrtRatioAX96]\n  }\n  const intermediate = JSBI.divide(JSBI.multiply(sqrtRatioAX96, sqrtRatioBX96), Q96)\n  return JSBI.divide(JSBI.multiply(JSBI.BigInt(amount0), intermediate), JSBI.subtract(sqrtRatioBX96, sqrtRatioAX96))\n}\n\nfunction maxLiquidityForAmount0Precise(sqrtRatioAX96: JSBI, sqrtRatioBX96: JSBI, amount0: BigintIsh): JSBI {\n  if (JSBI.greaterThan(sqrtRatioAX96, sqrtRatioBX96)) {\n    ;[sqrtRatioAX96, sqrtRatioBX96] = [sqrtRatioBX96, sqrtRatioAX96]\n  }\n\n  const numerator = JSBI.multiply(JSBI.multiply(JSBI.BigInt(amount0), sqrtRatioAX96), sqrtRatioBX96)\n  const denominator = JSBI.multiply(Q96, JSBI.subtract(sqrtRatioBX96, sqrtRatioAX96))\n\n  return JSBI.divide(numerator, denominator)\n}\n\nfunction maxLiquidityForAmount1(sqrtRatioAX96: JSBI, sqrtRatioBX96: JSBI, amount1: BigintIsh): JSBI {\n  if (JSBI.greaterThan(sqrtRatioAX96, sqrtRatioBX96)) {\n    ;[sqrtRatioAX96, sqrtRatioBX96] = [sqrtRatioBX96, sqrtRatioAX96]\n  }\n  return JSBI.divide(JSBI.multiply(JSBI.BigInt(amount1), Q96), JSBI.subtract(sqrtRatioBX96, sqrtRatioAX96))\n}\n\n/**\n * Computes the maximum amount of liquidity received for a given amount of token0, token1,\n * and the prices at the tick boundaries.\n * @param sqrtRatioCurrentX96 the current price\n * @param sqrtRatioAX96 price at lower boundary\n * @param sqrtRatioBX96 price at upper boundary\n * @param amount0 token0 amount\n * @param amount1 token1 amount\n * @param useFullPrecision if false, liquidity will be maximized according to what the router can calculate,\n * not what core can theoretically support\n */\nexport function maxLiquidityForAmounts(\n  sqrtRatioCurrentX96: JSBI,\n  sqrtRatioAX96: JSBI,\n  sqrtRatioBX96: JSBI,\n  amount0: BigintIsh,\n  amount1: BigintIsh,\n  useFullPrecision: boolean\n): JSBI {\n  if (JSBI.greaterThan(sqrtRatioAX96, sqrtRatioBX96)) {\n    ;[sqrtRatioAX96, sqrtRatioBX96] = [sqrtRatioBX96, sqrtRatioAX96]\n  }\n\n  const maxLiquidityForAmount0 = useFullPrecision ? maxLiquidityForAmount0Precise : maxLiquidityForAmount0Imprecise\n\n  if (JSBI.lessThanOrEqual(sqrtRatioCurrentX96, sqrtRatioAX96)) {\n    return maxLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0)\n  } else if (JSBI.lessThan(sqrtRatioCurrentX96, sqrtRatioBX96)) {\n    const liquidity0 = maxLiquidityForAmount0(sqrtRatioCurrentX96, sqrtRatioBX96, amount0)\n    const liquidity1 = maxLiquidityForAmount1(sqrtRatioAX96, sqrtRatioCurrentX96, amount1)\n    return JSBI.lessThan(liquidity0, liquidity1) ? liquidity0 : liquidity1\n  } else {\n    return maxLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1)\n  }\n}\n","import { Price, Token } from '@uniswap/sdk-core'\nimport JSBI from 'jsbi'\nimport { Q192 } from '../internalConstants'\nimport { encodeSqrtRatioX96 } from './encodeSqrtRatioX96'\nimport { TickMath } from './tickMath'\n\n/**\n * Returns a price object corresponding to the input tick and the base/quote token\n * Inputs must be tokens because the address order is used to interpret the price represented by the tick\n * @param baseToken the base token of the price\n * @param quoteToken the quote token of the price\n * @param tick the tick for which to return the price\n */\nexport function tickToPrice(baseToken: Token, quoteToken: Token, tick: number): Price<Token, Token> {\n  const sqrtRatioX96 = TickMath.getSqrtRatioAtTick(tick)\n\n  const ratioX192 = JSBI.multiply(sqrtRatioX96, sqrtRatioX96)\n\n  return baseToken.sortsBefore(quoteToken)\n    ? new Price(baseToken, quoteToken, Q192, ratioX192)\n    : new Price(baseToken, quoteToken, ratioX192, Q192)\n}\n\n/**\n * Returns the first tick for which the given price is greater than or equal to the tick price\n * @param price for which to return the closest tick that represents a price less than or equal to the input price,\n * i.e. the price of the returned tick is less than or equal to the input price\n */\nexport function priceToClosestTick(price: Price<Token, Token>): number {\n  const sorted = price.baseCurrency.sortsBefore(price.quoteCurrency)\n\n  const sqrtRatioX96 = sorted\n    ? encodeSqrtRatioX96(price.numerator, price.denominator)\n    : encodeSqrtRatioX96(price.denominator, price.numerator)\n\n  let tick = TickMath.getTickAtSqrtRatio(sqrtRatioX96)\n  const nextTickPrice = tickToPrice(price.baseCurrency, price.quoteCurrency, tick + 1)\n  if (sorted) {\n    if (!price.lessThan(nextTickPrice)) {\n      tick++\n    }\n  } else {\n    if (!price.greaterThan(nextTickPrice)) {\n      tick++\n    }\n  }\n  return tick\n}\n","import JSBI from 'jsbi'\nimport invariant from 'tiny-invariant'\nimport { BigintIsh } from '@uniswap/sdk-core'\nimport { TickMath } from '../utils'\n\nexport interface TickConstructorArgs {\n  index: number\n  liquidityGross: BigintIsh\n  liquidityNet: BigintIsh\n}\n\nexport class Tick {\n  public readonly index: number\n  public readonly liquidityGross: JSBI\n  public readonly liquidityNet: JSBI\n\n  constructor({ index, liquidityGross, liquidityNet }: TickConstructorArgs) {\n    invariant(index >= TickMath.MIN_TICK && index <= TickMath.MAX_TICK, 'TICK')\n    this.index = index\n    this.liquidityGross = JSBI.BigInt(liquidityGross)\n    this.liquidityNet = JSBI.BigInt(liquidityNet)\n  }\n}\n","import { BigintIsh } from '@uniswap/sdk-core'\nimport { TickList } from '../utils/tickList'\nimport { Tick, TickConstructorArgs } from './tick'\nimport { TickDataProvider } from './tickDataProvider'\n\n/**\n * A data provider for ticks that is backed by an in-memory array of ticks.\n */\nexport class TickListDataProvider implements TickDataProvider {\n  private ticks: readonly Tick[]\n\n  constructor(ticks: (Tick | TickConstructorArgs)[], tickSpacing: number) {\n    const ticksMapped: Tick[] = ticks.map(t => (t instanceof Tick ? t : new Tick(t)))\n    TickList.validateList(ticksMapped, tickSpacing)\n    this.ticks = ticksMapped\n  }\n\n  async getTick(tick: number): Promise<{ liquidityNet: BigintIsh; liquidityGross: BigintIsh }> {\n    return TickList.getTick(this.ticks, tick)\n  }\n\n  async nextInitializedTickWithinOneWord(tick: number, lte: boolean, tickSpacing: number): Promise<[number, boolean]> {\n    return TickList.nextInitializedTickWithinOneWord(this.ticks, tick, lte, tickSpacing)\n  }\n}\n","import { BigintIsh, ChainId, Price, Token, CurrencyAmount } from '@uniswap/sdk-core'\nimport JSBI from 'jsbi'\nimport invariant from 'tiny-invariant'\nimport { FACTORY_ADDRESS, FeeAmount, TICK_SPACINGS } from '../constants'\nimport { NEGATIVE_ONE, ONE, Q192, ZERO } from '../internalConstants'\nimport { computePoolAddress } from '../utils/computePoolAddress'\nimport { LiquidityMath } from '../utils/liquidityMath'\nimport { SwapMath } from '../utils/swapMath'\nimport { TickMath } from '../utils/tickMath'\nimport { Tick, TickConstructorArgs } from './tick'\nimport { NoTickDataProvider, TickDataProvider } from './tickDataProvider'\nimport { TickListDataProvider } from './tickListDataProvider'\n\ninterface StepComputations {\n  sqrtPriceStartX96: JSBI\n  tickNext: number\n  initialized: boolean\n  sqrtPriceNextX96: JSBI\n  amountIn: JSBI\n  amountOut: JSBI\n  feeAmount: JSBI\n}\n\n/**\n * By default, pools will not allow operations that require ticks.\n */\nconst NO_TICK_DATA_PROVIDER_DEFAULT = new NoTickDataProvider()\n\n/**\n * Represents a V3 pool\n */\nexport class Pool {\n  public readonly token0: Token\n  public readonly token1: Token\n  public readonly fee: FeeAmount\n  public readonly sqrtRatioX96: JSBI\n  public readonly liquidity: JSBI\n  public readonly tickCurrent: number\n  public readonly tickDataProvider: TickDataProvider\n\n  private _token0Price?: Price<Token, Token>\n  private _token1Price?: Price<Token, Token>\n\n  public static getAddress(tokenA: Token, tokenB: Token, fee: FeeAmount): string {\n    return computePoolAddress({ factoryAddress: FACTORY_ADDRESS, fee, tokenA, tokenB })\n  }\n\n  /**\n   * Construct a pool\n   * @param tokenA one of the tokens in the pool\n   * @param tokenB the other token in the pool\n   * @param fee the fee in hundredths of a bips of the input amount of every swap that is collected by the pool\n   * @param sqrtRatioX96 the sqrt of the current ratio of amounts of token1 to token0\n   * @param liquidity the current value of in range liquidity\n   * @param tickCurrent the current tick of the pool\n   * @param ticks the current state of the pool ticks or a data provider that can return tick data\n   */\n  public constructor(\n    tokenA: Token,\n    tokenB: Token,\n    fee: FeeAmount,\n    sqrtRatioX96: BigintIsh,\n    liquidity: BigintIsh,\n    tickCurrent: number,\n    ticks: TickDataProvider | (Tick | TickConstructorArgs)[] = NO_TICK_DATA_PROVIDER_DEFAULT\n  ) {\n    invariant(Number.isInteger(fee) && fee < 1_000_000, 'FEE')\n\n    const tickCurrentSqrtRatioX96 = TickMath.getSqrtRatioAtTick(tickCurrent)\n    const nextTickSqrtRatioX96 = TickMath.getSqrtRatioAtTick(tickCurrent + 1)\n    invariant(\n      JSBI.greaterThanOrEqual(JSBI.BigInt(sqrtRatioX96), tickCurrentSqrtRatioX96) &&\n        JSBI.lessThanOrEqual(JSBI.BigInt(sqrtRatioX96), nextTickSqrtRatioX96),\n      'PRICE_BOUNDS'\n    )\n    // always create a copy of the list since we want the pool's tick list to be immutable\n    ;[this.token0, this.token1] = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA]\n    this.fee = fee\n    this.sqrtRatioX96 = JSBI.BigInt(sqrtRatioX96)\n    this.liquidity = JSBI.BigInt(liquidity)\n    this.tickCurrent = tickCurrent\n    this.tickDataProvider = Array.isArray(ticks) ? new TickListDataProvider(ticks, TICK_SPACINGS[fee]) : ticks\n  }\n\n  /**\n   * Returns true if the token is either token0 or token1\n   * @param token to check\n   */\n  public involvesToken(token: Token): boolean {\n    return token.equals(this.token0) || token.equals(this.token1)\n  }\n\n  /**\n   * Returns the current mid price of the pool in terms of token0, i.e. the ratio of token1 over token0\n   */\n  public get token0Price(): Price<Token, Token> {\n    return (\n      this._token0Price ??\n      (this._token0Price = new Price(\n        this.token0,\n        this.token1,\n        Q192,\n        JSBI.multiply(this.sqrtRatioX96, this.sqrtRatioX96)\n      ))\n    )\n  }\n\n  /**\n   * Returns the current mid price of the pool in terms of token1, i.e. the ratio of token0 over token1\n   */\n  public get token1Price(): Price<Token, Token> {\n    return (\n      this._token1Price ??\n      (this._token1Price = new Price(\n        this.token1,\n        this.token0,\n        JSBI.multiply(this.sqrtRatioX96, this.sqrtRatioX96),\n        Q192\n      ))\n    )\n  }\n\n  /**\n   * Return the price of the given token in terms of the other token in the pool.\n   * @param token token to return price of\n   */\n  public priceOf(token: Token): Price<Token, Token> {\n    invariant(this.involvesToken(token), 'TOKEN')\n    return token.equals(this.token0) ? this.token0Price : this.token1Price\n  }\n\n  /**\n   * Returns the chain ID of the tokens in the pool.\n   */\n  public get chainId(): ChainId | number {\n    return this.token0.chainId\n  }\n\n  /**\n   * Given an input amount of a token, return the computed output amount and a pool with state updated after the trade\n   * @param inputAmount the input amount for which to quote the output amount\n   */\n  public async getOutputAmount(\n    inputAmount: CurrencyAmount<Token>,\n    sqrtPriceLimitX96?: JSBI\n  ): Promise<[CurrencyAmount<Token>, Pool]> {\n    invariant(this.involvesToken(inputAmount.currency), 'TOKEN')\n\n    const zeroForOne = inputAmount.currency.equals(this.token0)\n\n    const { amountCalculated: outputAmount, sqrtRatioX96, liquidity, tickCurrent } = await this.swap(\n      zeroForOne,\n      inputAmount.quotient,\n      sqrtPriceLimitX96\n    )\n    const outputToken = zeroForOne ? this.token1 : this.token0\n    return [\n      CurrencyAmount.fromRawAmount(outputToken, JSBI.multiply(outputAmount, NEGATIVE_ONE)),\n      new Pool(this.token0, this.token1, this.fee, sqrtRatioX96, liquidity, tickCurrent, this.tickDataProvider)\n    ]\n  }\n\n  /**\n   * Given a desired output amount of a token, return the computed input amount and a pool with state updated after the trade\n   * @param outputAmount the output amount for which to quote the input amount\n   */\n  public async getInputAmount(\n    outputAmount: CurrencyAmount<Token>,\n    sqrtPriceLimitX96?: JSBI\n  ): Promise<[CurrencyAmount<Token>, Pool]> {\n    invariant(outputAmount.currency.isToken && this.involvesToken(outputAmount.currency), 'TOKEN')\n\n    const zeroForOne = outputAmount.currency.equals(this.token1)\n\n    const { amountCalculated: inputAmount, sqrtRatioX96, liquidity, tickCurrent } = await this.swap(\n      zeroForOne,\n      JSBI.multiply(outputAmount.quotient, NEGATIVE_ONE),\n      sqrtPriceLimitX96\n    )\n    const inputToken = zeroForOne ? this.token0 : this.token1\n    return [\n      CurrencyAmount.fromRawAmount(inputToken, inputAmount),\n      new Pool(this.token0, this.token1, this.fee, sqrtRatioX96, liquidity, tickCurrent, this.tickDataProvider)\n    ]\n  }\n\n  private async swap(\n    zeroForOne: boolean,\n    amountSpecified: JSBI,\n    sqrtPriceLimitX96?: JSBI\n  ): Promise<{ amountCalculated: JSBI; sqrtRatioX96: JSBI; liquidity: JSBI; tickCurrent: number }> {\n    if (!sqrtPriceLimitX96)\n      sqrtPriceLimitX96 = zeroForOne\n        ? JSBI.add(TickMath.MIN_SQRT_RATIO, ONE)\n        : JSBI.subtract(TickMath.MAX_SQRT_RATIO, ONE)\n\n    if (zeroForOne) {\n      invariant(JSBI.greaterThan(sqrtPriceLimitX96, TickMath.MIN_SQRT_RATIO), 'RATIO_MIN')\n      invariant(JSBI.lessThan(sqrtPriceLimitX96, this.sqrtRatioX96), 'RATIO_CURRENT')\n    } else {\n      invariant(JSBI.lessThan(sqrtPriceLimitX96, TickMath.MAX_SQRT_RATIO), 'RATIO_MAX')\n      invariant(JSBI.greaterThan(sqrtPriceLimitX96, this.sqrtRatioX96), 'RATIO_CURRENT')\n    }\n\n    const exactInput = JSBI.greaterThanOrEqual(amountSpecified, ZERO)\n\n    // keep track of swap state\n    const state = {\n      amountSpecifiedRemaining: amountSpecified,\n      amountCalculated: ZERO,\n      sqrtPriceX96: this.sqrtRatioX96,\n      tick: this.tickCurrent,\n      liquidity: this.liquidity\n    }\n\n    // start swap while loop\n    while (JSBI.notEqual(state.amountSpecifiedRemaining, ZERO) && state.sqrtPriceX96 != sqrtPriceLimitX96) {\n      let step: Partial<StepComputations> = {}\n      step.sqrtPriceStartX96 = state.sqrtPriceX96\n\n      // because each iteration of the while loop rounds, we can't optimize this code (relative to the smart contract)\n      // by simply traversing to the next available tick, we instead need to exactly replicate\n      // tickBitmap.nextInitializedTickWithinOneWord\n      ;[step.tickNext, step.initialized] = await this.tickDataProvider.nextInitializedTickWithinOneWord(\n        state.tick,\n        zeroForOne,\n        this.tickSpacing\n      )\n\n      if (step.tickNext < TickMath.MIN_TICK) {\n        step.tickNext = TickMath.MIN_TICK\n      } else if (step.tickNext > TickMath.MAX_TICK) {\n        step.tickNext = TickMath.MAX_TICK\n      }\n\n      step.sqrtPriceNextX96 = TickMath.getSqrtRatioAtTick(step.tickNext)\n      ;[state.sqrtPriceX96, step.amountIn, step.amountOut, step.feeAmount] = SwapMath.computeSwapStep(\n        state.sqrtPriceX96,\n        (zeroForOne\n        ? JSBI.lessThan(step.sqrtPriceNextX96, sqrtPriceLimitX96)\n        : JSBI.greaterThan(step.sqrtPriceNextX96, sqrtPriceLimitX96))\n          ? sqrtPriceLimitX96\n          : step.sqrtPriceNextX96,\n        state.liquidity,\n        state.amountSpecifiedRemaining,\n        this.fee\n      )\n\n      if (exactInput) {\n        state.amountSpecifiedRemaining = JSBI.subtract(\n          state.amountSpecifiedRemaining,\n          JSBI.add(step.amountIn, step.feeAmount)\n        )\n        state.amountCalculated = JSBI.subtract(state.amountCalculated, step.amountOut)\n      } else {\n        state.amountSpecifiedRemaining = JSBI.add(state.amountSpecifiedRemaining, step.amountOut)\n        state.amountCalculated = JSBI.add(state.amountCalculated, JSBI.add(step.amountIn, step.feeAmount))\n      }\n\n      // TODO\n      if (JSBI.equal(state.sqrtPriceX96, step.sqrtPriceNextX96)) {\n        // if the tick is initialized, run the tick transition\n        if (step.initialized) {\n          let liquidityNet = JSBI.BigInt((await this.tickDataProvider.getTick(step.tickNext)).liquidityNet)\n          // if we're moving leftward, we interpret liquidityNet as the opposite sign\n          // safe because liquidityNet cannot be type(int128).min\n          if (zeroForOne) liquidityNet = JSBI.multiply(liquidityNet, NEGATIVE_ONE)\n\n          state.liquidity = LiquidityMath.addDelta(state.liquidity, liquidityNet)\n        }\n\n        state.tick = zeroForOne ? step.tickNext - 1 : step.tickNext\n      } else if (state.sqrtPriceX96 != step.sqrtPriceStartX96) {\n        // recompute unless we're on a lower tick boundary (i.e. already transitioned ticks), and haven't moved\n        state.tick = TickMath.getTickAtSqrtRatio(state.sqrtPriceX96)\n      }\n    }\n\n    return {\n      amountCalculated: state.amountCalculated,\n      sqrtRatioX96: state.sqrtPriceX96,\n      liquidity: state.liquidity,\n      tickCurrent: state.tick\n    }\n  }\n\n  public get tickSpacing(): number {\n    return TICK_SPACINGS[this.fee]\n  }\n}\n","import { BigintIsh, MaxUint256, Percent, Price, CurrencyAmount, Token } from '@uniswap/sdk-core'\nimport JSBI from 'jsbi'\nimport invariant from 'tiny-invariant'\nimport { ZERO } from '../internalConstants'\nimport { maxLiquidityForAmounts } from '../utils/maxLiquidityForAmounts'\nimport { tickToPrice } from '../utils/priceTickConversions'\nimport { SqrtPriceMath } from '../utils/sqrtPriceMath'\nimport { TickMath } from '../utils/tickMath'\nimport { encodeSqrtRatioX96 } from '../utils/encodeSqrtRatioX96'\nimport { Pool } from './pool'\n\ninterface PositionConstructorArgs {\n  pool: Pool\n  tickLower: number\n  tickUpper: number\n  liquidity: BigintIsh\n}\n\n/**\n * Represents a position on a Uniswap V3 Pool\n */\nexport class Position {\n  public readonly pool: Pool\n  public readonly tickLower: number\n  public readonly tickUpper: number\n  public readonly liquidity: JSBI\n\n  // cached resuts for the getters\n  private _token0Amount: CurrencyAmount<Token> | null = null\n  private _token1Amount: CurrencyAmount<Token> | null = null\n  private _mintAmounts: Readonly<{ amount0: JSBI; amount1: JSBI }> | null = null\n\n  /**\n   * Constructs a position for a given pool with the given liquidity\n   * @param pool for which pool the liquidity is assigned\n   * @param liquidity the amount of liquidity that is in the position\n   * @param tickLower the lower tick of the position\n   * @param tickUpper the upper tick of the position\n   */\n  public constructor({ pool, liquidity, tickLower, tickUpper }: PositionConstructorArgs) {\n    invariant(tickLower < tickUpper, 'TICK_ORDER')\n    invariant(tickLower >= TickMath.MIN_TICK && tickLower % pool.tickSpacing === 0, 'TICK_LOWER')\n    invariant(tickUpper <= TickMath.MAX_TICK && tickUpper % pool.tickSpacing === 0, 'TICK_UPPER')\n\n    this.pool = pool\n    this.tickLower = tickLower\n    this.tickUpper = tickUpper\n    this.liquidity = JSBI.BigInt(liquidity)\n  }\n\n  /**\n   * Returns the price of token0 at the lower tick\n   */\n  public get token0PriceLower(): Price<Token, Token> {\n    return tickToPrice(this.pool.token0, this.pool.token1, this.tickLower)\n  }\n\n  /**\n   * Returns the price of token0 at the upper tick\n   */\n  public get token0PriceUpper(): Price<Token, Token> {\n    return tickToPrice(this.pool.token0, this.pool.token1, this.tickUpper)\n  }\n\n  /**\n   * Returns the amount of token0 that this position's liquidity could be burned for at the current pool price\n   */\n  public get amount0(): CurrencyAmount<Token> {\n    if (this._token0Amount === null) {\n      if (this.pool.tickCurrent < this.tickLower) {\n        this._token0Amount = CurrencyAmount.fromRawAmount(\n          this.pool.token0,\n          SqrtPriceMath.getAmount0Delta(\n            TickMath.getSqrtRatioAtTick(this.tickLower),\n            TickMath.getSqrtRatioAtTick(this.tickUpper),\n            this.liquidity,\n            false\n          )\n        )\n      } else if (this.pool.tickCurrent < this.tickUpper) {\n        this._token0Amount = CurrencyAmount.fromRawAmount(\n          this.pool.token0,\n          SqrtPriceMath.getAmount0Delta(\n            this.pool.sqrtRatioX96,\n            TickMath.getSqrtRatioAtTick(this.tickUpper),\n            this.liquidity,\n            false\n          )\n        )\n      } else {\n        this._token0Amount = CurrencyAmount.fromRawAmount(this.pool.token0, ZERO)\n      }\n    }\n    return this._token0Amount\n  }\n\n  /**\n   * Returns the amount of token1 that this position's liquidity could be burned for at the current pool price\n   */\n  public get amount1(): CurrencyAmount<Token> {\n    if (this._token1Amount === null) {\n      if (this.pool.tickCurrent < this.tickLower) {\n        this._token1Amount = CurrencyAmount.fromRawAmount(this.pool.token1, ZERO)\n      } else if (this.pool.tickCurrent < this.tickUpper) {\n        this._token1Amount = CurrencyAmount.fromRawAmount(\n          this.pool.token1,\n          SqrtPriceMath.getAmount1Delta(\n            TickMath.getSqrtRatioAtTick(this.tickLower),\n            this.pool.sqrtRatioX96,\n            this.liquidity,\n            false\n          )\n        )\n      } else {\n        this._token1Amount = CurrencyAmount.fromRawAmount(\n          this.pool.token1,\n          SqrtPriceMath.getAmount1Delta(\n            TickMath.getSqrtRatioAtTick(this.tickLower),\n            TickMath.getSqrtRatioAtTick(this.tickUpper),\n            this.liquidity,\n            false\n          )\n        )\n      }\n    }\n    return this._token1Amount\n  }\n\n  /**\n   * Returns the lower and upper sqrt ratios if the price 'slips' up to slippage tolerance percentage\n   * @param slippageTolerance amount by which the price can 'slip'\n   * @private\n   */\n  private ratiosAfterSlippage(slippageTolerance: Percent): { sqrtRatioX96Lower: JSBI; sqrtRatioX96Upper: JSBI } {\n    const priceLower = this.pool.token0Price.asFraction.multiply(new Percent(1).subtract(slippageTolerance))\n    const priceUpper = this.pool.token0Price.asFraction.multiply(slippageTolerance.add(1))\n    let sqrtRatioX96Lower = encodeSqrtRatioX96(priceLower.numerator, priceLower.denominator)\n    if (JSBI.lessThanOrEqual(sqrtRatioX96Lower, TickMath.MIN_SQRT_RATIO)) {\n      sqrtRatioX96Lower = JSBI.add(TickMath.MIN_SQRT_RATIO, JSBI.BigInt(1))\n    }\n    let sqrtRatioX96Upper = encodeSqrtRatioX96(priceUpper.numerator, priceUpper.denominator)\n    if (JSBI.greaterThanOrEqual(sqrtRatioX96Upper, TickMath.MAX_SQRT_RATIO)) {\n      sqrtRatioX96Upper = JSBI.subtract(TickMath.MAX_SQRT_RATIO, JSBI.BigInt(1))\n    }\n    return {\n      sqrtRatioX96Lower,\n      sqrtRatioX96Upper\n    }\n  }\n\n  /**\n   * Returns the minimum amounts that must be sent in order to safely mint the amount of liquidity held by the position\n   * with the given slippage tolerance\n   * @param slippageTolerance tolerance of unfavorable slippage from the current price\n   */\n  public mintAmountsWithSlippage(slippageTolerance: Percent): Readonly<{ amount0: JSBI; amount1: JSBI }> {\n    // get lower/upper prices\n    const { sqrtRatioX96Upper, sqrtRatioX96Lower } = this.ratiosAfterSlippage(slippageTolerance)\n\n    // construct counterfactual pools\n    const poolLower = new Pool(\n      this.pool.token0,\n      this.pool.token1,\n      this.pool.fee,\n      sqrtRatioX96Lower,\n      0 /* liquidity doesn't matter */,\n      TickMath.getTickAtSqrtRatio(sqrtRatioX96Lower)\n    )\n    const poolUpper = new Pool(\n      this.pool.token0,\n      this.pool.token1,\n      this.pool.fee,\n      sqrtRatioX96Upper,\n      0 /* liquidity doesn't matter */,\n      TickMath.getTickAtSqrtRatio(sqrtRatioX96Upper)\n    )\n\n    // because the router is imprecise, we need to calculate the position that will be created (assuming no slippage)\n    const positionThatWillBeCreated = Position.fromAmounts({\n      pool: this.pool,\n      tickLower: this.tickLower,\n      tickUpper: this.tickUpper,\n      ...this.mintAmounts, // the mint amounts are what will be passed as calldata\n      useFullPrecision: false\n    })\n\n    // we want the smaller amounts...\n    // ...which occurs at the upper price for amount0...\n    const { amount0 } = new Position({\n      pool: poolUpper,\n      liquidity: positionThatWillBeCreated.liquidity,\n      tickLower: this.tickLower,\n      tickUpper: this.tickUpper\n    }).mintAmounts\n    // ...and the lower for amount1\n    const { amount1 } = new Position({\n      pool: poolLower,\n      liquidity: positionThatWillBeCreated.liquidity,\n      tickLower: this.tickLower,\n      tickUpper: this.tickUpper\n    }).mintAmounts\n\n    return { amount0, amount1 }\n  }\n\n  /**\n   * Returns the minimum amounts that should be requested in order to safely burn the amount of liquidity held by the\n   * position with the given slippage tolerance\n   * @param slippageTolerance tolerance of unfavorable slippage from the current price\n   */\n  public burnAmountsWithSlippage(slippageTolerance: Percent): Readonly<{ amount0: JSBI; amount1: JSBI }> {\n    // get lower/upper prices\n    const { sqrtRatioX96Upper, sqrtRatioX96Lower } = this.ratiosAfterSlippage(slippageTolerance)\n\n    // construct counterfactual pools\n    const poolLower = new Pool(\n      this.pool.token0,\n      this.pool.token1,\n      this.pool.fee,\n      sqrtRatioX96Lower,\n      0 /* liquidity doesn't matter */,\n      TickMath.getTickAtSqrtRatio(sqrtRatioX96Lower)\n    )\n    const poolUpper = new Pool(\n      this.pool.token0,\n      this.pool.token1,\n      this.pool.fee,\n      sqrtRatioX96Upper,\n      0 /* liquidity doesn't matter */,\n      TickMath.getTickAtSqrtRatio(sqrtRatioX96Upper)\n    )\n\n    // we want the smaller amounts...\n    // ...which occurs at the upper price for amount0...\n    const amount0 = new Position({\n      pool: poolUpper,\n      liquidity: this.liquidity,\n      tickLower: this.tickLower,\n      tickUpper: this.tickUpper\n    }).amount0\n    // ...and the lower for amount1\n    const amount1 = new Position({\n      pool: poolLower,\n      liquidity: this.liquidity,\n      tickLower: this.tickLower,\n      tickUpper: this.tickUpper\n    }).amount1\n\n    return { amount0: amount0.quotient, amount1: amount1.quotient }\n  }\n\n  /**\n   * Returns the minimum amounts that must be sent in order to mint the amount of liquidity held by the position at\n   * the current price for the pool\n   */\n  public get mintAmounts(): Readonly<{ amount0: JSBI; amount1: JSBI }> {\n    if (this._mintAmounts === null) {\n      if (this.pool.tickCurrent < this.tickLower) {\n        return {\n          amount0: SqrtPriceMath.getAmount0Delta(\n            TickMath.getSqrtRatioAtTick(this.tickLower),\n            TickMath.getSqrtRatioAtTick(this.tickUpper),\n            this.liquidity,\n            true\n          ),\n          amount1: ZERO\n        }\n      } else if (this.pool.tickCurrent < this.tickUpper) {\n        return {\n          amount0: SqrtPriceMath.getAmount0Delta(\n            this.pool.sqrtRatioX96,\n            TickMath.getSqrtRatioAtTick(this.tickUpper),\n            this.liquidity,\n            true\n          ),\n          amount1: SqrtPriceMath.getAmount1Delta(\n            TickMath.getSqrtRatioAtTick(this.tickLower),\n            this.pool.sqrtRatioX96,\n            this.liquidity,\n            true\n          )\n        }\n      } else {\n        return {\n          amount0: ZERO,\n          amount1: SqrtPriceMath.getAmount1Delta(\n            TickMath.getSqrtRatioAtTick(this.tickLower),\n            TickMath.getSqrtRatioAtTick(this.tickUpper),\n            this.liquidity,\n            true\n          )\n        }\n      }\n    }\n    return this._mintAmounts\n  }\n\n  /**\n   * Computes the maximum amount of liquidity received for a given amount of token0, token1,\n   * and the prices at the tick boundaries.\n   * @param pool the pool for which the position should be created\n   * @param tickLower the lower tick of the position\n   * @param tickUpper the upper tick of the position\n   * @param amount0 token0 amount\n   * @param amount1 token1 amount\n   * @param useFullPrecision if false, liquidity will be maximized according to what the router can calculate,\n   * not what core can theoretically support\n   */\n  public static fromAmounts({\n    pool,\n    tickLower,\n    tickUpper,\n    amount0,\n    amount1,\n    useFullPrecision\n  }: {\n    pool: Pool\n    tickLower: number\n    tickUpper: number\n    amount0: BigintIsh\n    amount1: BigintIsh\n    useFullPrecision: boolean\n  }) {\n    const sqrtRatioAX96 = TickMath.getSqrtRatioAtTick(tickLower)\n    const sqrtRatioBX96 = TickMath.getSqrtRatioAtTick(tickUpper)\n    return new Position({\n      pool,\n      tickLower,\n      tickUpper,\n      liquidity: maxLiquidityForAmounts(\n        pool.sqrtRatioX96,\n        sqrtRatioAX96,\n        sqrtRatioBX96,\n        amount0,\n        amount1,\n        useFullPrecision\n      )\n    })\n  }\n\n  /**\n   * Computes a position with the maximum amount of liquidity received for a given amount of token0, assuming an unlimited amount of token1\n   * @param pool the pool for which the position is created\n   * @param tickLower the lower tick\n   * @param tickUpper the upper tick\n   * @param amount0 the desired amount of token0\n   * @param useFullPrecision if true, liquidity will be maximized according to what the router can calculate,\n   * not what core can theoretically support\n   */\n  public static fromAmount0({\n    pool,\n    tickLower,\n    tickUpper,\n    amount0,\n    useFullPrecision\n  }: {\n    pool: Pool\n    tickLower: number\n    tickUpper: number\n    amount0: BigintIsh\n    useFullPrecision: boolean\n  }) {\n    return Position.fromAmounts({ pool, tickLower, tickUpper, amount0, amount1: MaxUint256, useFullPrecision })\n  }\n\n  /**\n   * Computes a position with the maximum amount of liquidity received for a given amount of token1, assuming an unlimited amount of token0\n   * @param pool the pool for which the position is created\n   * @param tickLower the lower tick\n   * @param tickUpper the upper tick\n   * @param amount1 the desired amount of token1\n   */\n  public static fromAmount1({\n    pool,\n    tickLower,\n    tickUpper,\n    amount1\n  }: {\n    pool: Pool\n    tickLower: number\n    tickUpper: number\n    amount1: BigintIsh\n  }) {\n    // this function always uses full precision,\n    return Position.fromAmounts({ pool, tickLower, tickUpper, amount0: MaxUint256, amount1, useFullPrecision: true })\n  }\n}\n","import invariant from 'tiny-invariant'\n\nimport { ChainId, Currency, Price, Token ,WETH9} from '@uniswap/sdk-core'\nimport { Pool } from './pool'\n\nfunction wrappedCurrency(currency: Currency, chainId: ChainId): Token {\n  if (currency.isToken) {\n    // invariant(currency.chainId === chainId, 'CHAIN_ID')\n    return currency\n  }\n  if (chainId === 210000) {\n    const WJU = new Token(210000, '0x4d1b49b424afd7075d3c063addf97d5575e1c7e2', 18, 'WJU', 'Wrapped JU')\n    return WJU\n  }\n  if (currency.isEther) return WETH9[chainId]\n  throw new Error('CURRENCY')\n}\n/**\n * Represents a list of pools through which a swap can occur\n */\nexport class Route<TInput extends Currency, TOutput extends Currency> {\n  public readonly pools: Pool[]\n  public readonly tokenPath: Token[]\n  public readonly input: TInput\n  public readonly output: TOutput\n\n  private _midPrice: Price<TInput, TOutput> | null = null\n\n  public constructor(pools: Pool[], input: TInput, output: TOutput) {\n    invariant(pools.length > 0, 'POOLS')\n\n    const chainId = pools[0].chainId\n    const allOnSameChain = pools.every(pool => pool.chainId === chainId)\n    invariant(allOnSameChain, 'CHAIN_IDS')\n\n    const wrappedInput = wrappedCurrency(input, chainId)\n    invariant(pools[0].involvesToken(wrappedInput), 'INPUT')\n\n    invariant(pools[pools.length - 1].involvesToken(wrappedCurrency(output, chainId)), 'OUTPUT')\n\n    /**\n     * Normalizes token0-token1 order and selects the next token/fee step to add to the path\n     * */\n    const tokenPath: Token[] = [wrappedInput]\n    for (const [i, pool] of pools.entries()) {\n      const currentInputToken = tokenPath[i]\n      invariant(currentInputToken.equals(pool.token0) || currentInputToken.equals(pool.token1), 'PATH')\n      const nextToken = currentInputToken.equals(pool.token0) ? pool.token1 : pool.token0\n      tokenPath.push(nextToken)\n    }\n\n    this.pools = pools\n    this.tokenPath = tokenPath\n    this.input = input\n    this.output = output ?? tokenPath[tokenPath.length - 1]\n  }\n\n  public get chainId(): ChainId | number {\n    return this.pools[0].chainId\n  }\n\n  /**\n   * Returns the token representation of the input currency. If the input currency is Ether, returns the wrapped ether token.\n   */\n  public get inputToken(): Token {\n    return wrappedCurrency(this.input, this.chainId)\n  }\n\n  /**\n   * Returns the token representation of the output currency. If the output currency is Ether, returns the wrapped ether token.\n   */\n  public get outputToken(): Token {\n    return wrappedCurrency(this.output, this.chainId)\n  }\n\n  /**\n   * Returns the mid price of the route\n   */\n  public get midPrice(): Price<TInput, TOutput> {\n    if (this._midPrice !== null) return this._midPrice\n\n    const price = this.pools.slice(1).reduce(\n      ({ nextInput, price }, pool) => {\n        return nextInput.equals(pool.token0)\n          ? {\n              nextInput: pool.token1,\n              price: price.multiply(pool.token0Price)\n            }\n          : {\n              nextInput: pool.token0,\n              price: price.multiply(pool.token1Price)\n            }\n      },\n      this.pools[0].token0.equals(this.inputToken)\n        ? {\n            nextInput: this.pools[0].token1,\n            price: this.pools[0].token0Price\n          }\n        : {\n            nextInput: this.pools[0].token0,\n            price: this.pools[0].token1Price\n          }\n    ).price\n\n    return (this._midPrice = new Price(this.input, this.output, price.denominator, price.numerator))\n  }\n}\n","import {\r\n  ChainId,\r\n  Currency,\r\n  currencyEquals,\r\n  Fraction,\r\n  Percent,\r\n  Price,\r\n  sortedInsert,\r\n  CurrencyAmount,\r\n  TradeType,\r\n  wrappedCurrencyAmount,\r\n  Token,\r\n  computePriceImpact, WETH9\r\n} from '@uniswap/sdk-core'\r\nimport invariant from 'tiny-invariant'\r\n// import { ONE } from '../internalConstants'\r\nimport { Pool } from './pool'\r\nimport { Route } from './route'\r\n\r\nfunction wrappedCurrency(currency: Currency, chainId: ChainId): Token {\r\n  if (currency.isToken) {\r\n    // invariant(currency.chainId === chainId, 'CHAIN_ID')\r\n    return currency\r\n  }\r\n  if (chainId === 210000) {\r\n    const WJU = new Token(210000, '0x4d1b49b424afd7075d3c063addf97d5575e1c7e2', 18, 'WJU', 'Wrapped JU')\r\n    return WJU\r\n  }\r\n  if (currency.isEther) return WETH9[chainId]\r\n  throw new Error('CURRENCY')\r\n}\r\n\r\n// extension of the input output comparator that also considers other dimensions of the trade in ranking them\r\nexport function tradeComparator<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType>(\r\n  a: Trade<TInput, TOutput, TTradeType>,\r\n  b: Trade<TInput, TOutput, TTradeType>\r\n) {\r\n  // must have same input and output token for comparison\r\n  invariant(currencyEquals(a.inputAmount.currency, b.inputAmount.currency), 'INPUT_CURRENCY')\r\n  invariant(currencyEquals(a.outputAmount.currency, b.outputAmount.currency), 'OUTPUT_CURRENCY')\r\n  if (a.outputAmount.equalTo(b.outputAmount)) {\r\n    if (a.inputAmount.equalTo(b.inputAmount)) {\r\n      // consider the number of hops since each hop costs gas\r\n      return a.route.tokenPath.length - b.route.tokenPath.length\r\n    }\r\n    // trade A requires less input than trade B, so A should come first\r\n    if (a.inputAmount.lessThan(b.inputAmount)) {\r\n      return -1\r\n    } else {\r\n      return 1\r\n    }\r\n  } else {\r\n    // tradeA has less output than trade B, so should come second\r\n    if (a.outputAmount.lessThan(b.outputAmount)) {\r\n      return 1\r\n    } else {\r\n      return -1\r\n    }\r\n  }\r\n}\r\n\r\nexport interface BestTradeOptions {\r\n  // how many results to return\r\n  maxNumResults?: number\r\n  // the maximum number of hops a trade should contain\r\n  maxHops?: number\r\n}\r\n\r\n/**\r\n * Represents a trade executed against a list of pools.\r\n * Does not account for slippage, i.e. trades that front run this trade and move the price.\r\n */\r\nexport class Trade<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType> {\r\n  /**\r\n   * The route of the trade, i.e. which pools the trade goes through.\r\n   */\r\n  public readonly route: Route<TInput, TOutput>\r\n  /**\r\n   * The type of the trade, either exact in or exact out.\r\n   */\r\n  public readonly tradeType: TTradeType\r\n  /**\r\n   * The input amount for the trade assuming no slippage.\r\n   */\r\n  public readonly inputAmount: CurrencyAmount<TInput>\r\n  /**\r\n   * The output amount for the trade assuming no slippage.\r\n   */\r\n  public readonly outputAmount: CurrencyAmount<TOutput>\r\n\r\n  /**\r\n   * The cached result of the computed execution price\r\n   * @private\r\n   */\r\n  private _executionPrice: Price<TInput, TOutput> | undefined\r\n  /**\r\n   * The price expressed in terms of output amount/input amount.\r\n   */\r\n  public get executionPrice(): Price<TInput, TOutput> {\r\n    return (\r\n      this._executionPrice ??\r\n      (this._executionPrice = new Price(\r\n        this.inputAmount.currency,\r\n        this.outputAmount.currency,\r\n        this.inputAmount.quotient,\r\n        this.outputAmount.quotient\r\n      ))\r\n    )\r\n  }\r\n\r\n  /**\r\n   * The cached result of the price impact computation\r\n   * @private\r\n   */\r\n  private _priceImpact: Percent | undefined\r\n\r\n  /**\r\n   * Returns the percent difference between the route's mid price and the price impact\r\n   */\r\n  public get priceImpact(): Percent {\r\n    return (\r\n      this._priceImpact ??\r\n      (this._priceImpact = computePriceImpact(this.route.midPrice, this.inputAmount, this.outputAmount))\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Constructs an exact in trade with the given amount in and route\r\n   * @param route route of the exact in trade\r\n   * @param amountIn the amount being passed in\r\n   */\r\n  public static async exactIn<TInput extends Currency, TOutput extends Currency>(\r\n    route: Route<TInput, TOutput>,\r\n    amountIn: CurrencyAmount<TInput>\r\n  ): Promise<Trade<TInput, TOutput, TradeType.EXACT_INPUT>> {\r\n    return Trade.fromRoute(route, amountIn, TradeType.EXACT_INPUT)\r\n  }\r\n\r\n  /**\r\n   * Constructs an exact out trade with the given amount out and route\r\n   * @param route route of the exact out trade\r\n   * @param amountOut the amount returned by the trade\r\n   */\r\n  public static async exactOut<TInput extends Currency, TOutput extends Currency>(\r\n    route: Route<TInput, TOutput>,\r\n    amountOut: CurrencyAmount<TOutput>\r\n  ): Promise<Trade<TInput, TOutput, TradeType.EXACT_OUTPUT>> {\r\n    return Trade.fromRoute(route, amountOut, TradeType.EXACT_OUTPUT)\r\n  }\r\n\r\n  /**\r\n   * Constructs a trade by simulating swaps through the given route\r\n   * @param route route to swap through\r\n   * @param amount the amount specified, either input or output, depending on tradeType\r\n   * @param tradeType whether the trade is an exact input or exact output swap\r\n   */\r\n  public static async fromRoute<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType>(\r\n    route: Route<TInput, TOutput>,\r\n    amount: TTradeType extends TradeType.EXACT_INPUT ? CurrencyAmount<TInput> : CurrencyAmount<TOutput>,\r\n    tradeType: TTradeType\r\n  ): Promise<Trade<TInput, TOutput, TTradeType>> {\r\n    const amounts: CurrencyAmount<Token>[] = new Array(route.tokenPath.length)\r\n    let inputAmount: CurrencyAmount<TInput>\r\n    let outputAmount: CurrencyAmount<TOutput>\r\n    if (tradeType === TradeType.EXACT_INPUT) {\r\n      invariant(currencyEquals(amount.currency, route.input), 'INPUT')\r\n      amounts[0] = wrappedCurrencyAmount(amount, route.chainId)\r\n      for (let i = 0; i < route.tokenPath.length - 1; i++) {\r\n        const pool = route.pools[i]\r\n        const [outputAmount] = await pool.getOutputAmount(amounts[i])\r\n        amounts[i + 1] = outputAmount\r\n      }\r\n      inputAmount = CurrencyAmount.fromFractionalAmount(route.input, amount.numerator, amount.denominator)\r\n      outputAmount = CurrencyAmount.fromFractionalAmount(\r\n        route.output,\r\n        amounts[amounts.length - 1].numerator,\r\n        amounts[amounts.length - 1].denominator\r\n      )\r\n    } else {\r\n      invariant(currencyEquals(amount.currency, route.output), 'OUTPUT')\r\n      amounts[amounts.length - 1] = wrappedCurrencyAmount(amount, route.chainId)\r\n      for (let i = route.tokenPath.length - 1; i > 0; i--) {\r\n        const pool = route.pools[i - 1]\r\n        const [inputAmount] = await pool.getInputAmount(amounts[i])\r\n        amounts[i - 1] = inputAmount\r\n      }\r\n      inputAmount = CurrencyAmount.fromFractionalAmount(route.input, amounts[0].numerator, amounts[0].denominator)\r\n      outputAmount = CurrencyAmount.fromFractionalAmount(route.output, amount.numerator, amount.denominator)\r\n    }\r\n\r\n    return new Trade({\r\n      route,\r\n      tradeType,\r\n      inputAmount,\r\n      outputAmount\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Creates a trade without computing the result of swapping through the route. Useful when you have simulated the trade\r\n   * elsewhere and do not have any tick data\r\n   * @param constructorArguments the arguments passed to the trade constructor\r\n   */\r\n  public static createUncheckedTrade<\r\n    TInput extends Currency,\r\n    TOutput extends Currency,\r\n    TTradeType extends TradeType\r\n  >(constructorArguments: {\r\n    route: Route<TInput, TOutput>\r\n    inputAmount: CurrencyAmount<TInput>\r\n    outputAmount: CurrencyAmount<TOutput>\r\n    tradeType: TTradeType\r\n  }): Trade<TInput, TOutput, TTradeType> {\r\n    return new Trade(constructorArguments)\r\n  }\r\n\r\n  /**\r\n   * Construct a trade by passing in the pre-computed property values\r\n   * @param route the route through which the trade occurs\r\n   * @param inputAmount the amount of input paid in the trade\r\n   * @param outputAmount the amount of output received in the trade\r\n   * @param tradeType the type of trade, exact input or exact output\r\n   */\r\n  private constructor({\r\n    route,\r\n    inputAmount,\r\n    outputAmount,\r\n    tradeType\r\n  }: {\r\n    route: Route<TInput, TOutput>\r\n    inputAmount: CurrencyAmount<TInput>\r\n    outputAmount: CurrencyAmount<TOutput>\r\n    tradeType: TTradeType\r\n  }) {\r\n    invariant(currencyEquals(inputAmount.currency, route.input), 'INPUT_CURRENCY_MATCH')\r\n    invariant(currencyEquals(outputAmount.currency, route.output), 'OUTPUT_CURRENCY_MATCH')\r\n    this.route = route\r\n    this.inputAmount = inputAmount\r\n    this.outputAmount = outputAmount\r\n    this.tradeType = tradeType\r\n  }\r\n\r\n  /**\r\n   * Get the minimum amount that must be received from this trade for the given slippage tolerance\r\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\r\n   */\r\n  public minimumAmountOut(slippageTolerance: Percent): CurrencyAmount<TOutput> {\r\n    invariant(!slippageTolerance.lessThan(\"0\"), 'SLIPPAGE_TOLERANCE')\r\n    if (this.tradeType === TradeType.EXACT_OUTPUT) {\r\n      return this.outputAmount\r\n    } else {\r\n      console.log(\"this.outputAmount.quotient\",this.outputAmount.quotient)\r\n      let q = new Fraction(\"1\")\r\n      try{\r\n        q = new Fraction(this.outputAmount.quotient)\r\n      }catch(e){\r\n        console.error(e)\r\n      }\r\n\r\n      const slippageAdjustedAmountOut = new Fraction(\"1\")\r\n        .add(slippageTolerance)\r\n        .invert()\r\n        .multiply(q).quotient\r\n      return CurrencyAmount.fromRawAmount(this.outputAmount.currency, slippageAdjustedAmountOut)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\r\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\r\n   */\r\n  public maximumAmountIn(slippageTolerance: Percent): CurrencyAmount<TInput> {\r\n    invariant(!slippageTolerance.lessThan(\"0\"), 'SLIPPAGE_TOLERANCE')\r\n    if (this.tradeType === TradeType.EXACT_INPUT) {\r\n      return this.inputAmount\r\n    } else {\r\n      const slippageAdjustedAmountIn = new Fraction(\"1\").add(slippageTolerance).multiply(this.inputAmount.quotient)\r\n        .quotient\r\n      return CurrencyAmount.fromRawAmount(this.inputAmount.currency, slippageAdjustedAmountIn)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Return the execution price after accounting for slippage tolerance\r\n   * @param slippageTolerance the allowed tolerated slippage\r\n   */\r\n  public worstExecutionPrice(slippageTolerance: Percent): Price<TInput, TOutput> {\r\n    return new Price(\r\n      this.inputAmount.currency,\r\n      this.outputAmount.currency,\r\n      this.maximumAmountIn(slippageTolerance).quotient,\r\n      this.minimumAmountOut(slippageTolerance).quotient\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Given a list of pools, and a fixed amount in, returns the top `maxNumResults` trades that go from an input token\r\n   * amount to an output token, making at most `maxHops` hops.\r\n   * Note this does not consider aggregation, as routes are linear. It's possible a better route exists by splitting\r\n   * the amount in among multiple routes.\r\n   * @param pools the pools to consider in finding the best trade\r\n   * @param nextAmountIn exact amount of input currency to spend\r\n   * @param currencyOut the desired currency out\r\n   * @param maxNumResults maximum number of results to return\r\n   * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pool\r\n   * @param currentPools used in recursion; the current list of pools\r\n   * @param currencyAmountIn used in recursion; the original value of the currencyAmountIn parameter\r\n   * @param bestTrades used in recursion; the current list of best trades\r\n   */\r\n  public static async bestTradeExactIn<TInput extends Currency, TOutput extends Currency>(\r\n    pools: Pool[],\r\n    currencyAmountIn: CurrencyAmount<TInput>,\r\n    currencyOut: TOutput,\r\n    { maxNumResults = 3, maxHops = 3 }: BestTradeOptions = {},\r\n    // used in recursion.\r\n    currentPools: Pool[] = [],\r\n    nextAmountIn: CurrencyAmount<Currency> = currencyAmountIn,\r\n    bestTrades: Trade<TInput, TOutput, TradeType.EXACT_INPUT>[] = []\r\n  ): Promise<Trade<TInput, TOutput, TradeType.EXACT_INPUT>[]> {\r\n    invariant(pools.length > 0, 'POOLS')\r\n    invariant(maxHops > 0, 'MAX_HOPS')\r\n    invariant(currencyAmountIn === nextAmountIn || currentPools.length > 0, 'INVALID_RECURSION')\r\n    const chainId: ChainId | undefined = nextAmountIn.currency.isToken\r\n      ? nextAmountIn.currency.chainId\r\n      : currencyOut.isToken\r\n      ? (currencyOut as Token).chainId\r\n      : undefined\r\n    invariant(chainId !== undefined, 'CHAIN_ID')\r\n\r\n    const amountIn = wrappedCurrencyAmount(nextAmountIn, chainId)\r\n    const tokenOut = wrappedCurrency(currencyOut, chainId)\r\n    for (let i = 0; i < pools.length; i++) {\r\n      const pool = pools[i]\r\n      // pool irrelevant\r\n      if (!currencyEquals(pool.token0, amountIn.currency) && !currencyEquals(pool.token1, amountIn.currency)) continue\r\n\r\n      let amountOut: CurrencyAmount<Token>\r\n      try {\r\n        ;[amountOut] = await pool.getOutputAmount(amountIn)\r\n      } catch (error) {\r\n        // input too low\r\n        if (error.isInsufficientInputAmountError) {\r\n          continue\r\n        }\r\n        throw error\r\n      }\r\n      // we have arrived at the output token, so this is the final trade of one of the paths\r\n      if (amountOut.currency.isToken && amountOut.currency.equals(tokenOut)) {\r\n        sortedInsert(\r\n          bestTrades,\r\n          await Trade.fromRoute(\r\n            new Route([...currentPools, pool], currencyAmountIn.currency, currencyOut),\r\n            currencyAmountIn,\r\n            TradeType.EXACT_INPUT\r\n          ),\r\n          maxNumResults,\r\n          tradeComparator\r\n        )\r\n      } else if (maxHops > 1 && pools.length > 1) {\r\n        const poolsExcludingThisPool = pools.slice(0, i).concat(pools.slice(i + 1, pools.length))\r\n\r\n        // otherwise, consider all the other paths that lead from this token as long as we have not exceeded maxHops\r\n        await Trade.bestTradeExactIn(\r\n          poolsExcludingThisPool,\r\n          currencyAmountIn,\r\n          currencyOut,\r\n          {\r\n            maxNumResults,\r\n            maxHops: maxHops - 1\r\n          },\r\n          [...currentPools, pool],\r\n          amountOut,\r\n          bestTrades\r\n        )\r\n      }\r\n    }\r\n\r\n    return bestTrades\r\n  }\r\n\r\n  /**\r\n   * similar to the above method but instead targets a fixed output amount\r\n   * given a list of pools, and a fixed amount out, returns the top `maxNumResults` trades that go from an input token\r\n   * to an output token amount, making at most `maxHops` hops\r\n   * note this does not consider aggregation, as routes are linear. it's possible a better route exists by splitting\r\n   * the amount in among multiple routes.\r\n   * @param pools the pools to consider in finding the best trade\r\n   * @param currencyIn the currency to spend\r\n   * @param currencyAmountOut the desired currency amount out\r\n   * @param nextAmountOut the exact amount of currency out\r\n   * @param maxNumResults maximum number of results to return\r\n   * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pool\r\n   * @param currentPools used in recursion; the current list of pools\r\n   * @param bestTrades used in recursion; the current list of best trades\r\n   */\r\n  public static async bestTradeExactOut<TInput extends Currency, TOutput extends Currency>(\r\n    pools: Pool[],\r\n    currencyIn: Currency,\r\n    currencyAmountOut: CurrencyAmount<TOutput>,\r\n    { maxNumResults = 3, maxHops = 3 }: BestTradeOptions = {},\r\n    // used in recursion.\r\n    currentPools: Pool[] = [],\r\n    nextAmountOut: CurrencyAmount<Currency> = currencyAmountOut,\r\n    bestTrades: Trade<TInput, TOutput, TradeType.EXACT_OUTPUT>[] = []\r\n  ): Promise<Trade<TInput, TOutput, TradeType.EXACT_OUTPUT>[]> {\r\n    invariant(pools.length > 0, 'POOLS')\r\n    invariant(maxHops > 0, 'MAX_HOPS')\r\n    invariant(currencyAmountOut === nextAmountOut || currentPools.length > 0, 'INVALID_RECURSION')\r\n    const chainId: ChainId | undefined = nextAmountOut.currency.isToken\r\n      ? nextAmountOut.currency.chainId\r\n      : currencyIn.isToken\r\n      ? currencyIn.chainId\r\n      : undefined\r\n    invariant(chainId !== undefined, 'CHAIN_ID')\r\n\r\n    const amountOut = wrappedCurrencyAmount(nextAmountOut, chainId)\r\n    const tokenIn = wrappedCurrency(currencyIn, chainId)\r\n    for (let i = 0; i < pools.length; i++) {\r\n      const pool = pools[i]\r\n      // pool irrelevant\r\n      if (!currencyEquals(pool.token0, amountOut.currency) && !currencyEquals(pool.token1, amountOut.currency)) continue\r\n\r\n      let amountIn: CurrencyAmount<Token>\r\n      try {\r\n        ;[amountIn] = await pool.getInputAmount(amountOut)\r\n      } catch (error) {\r\n        // not enough liquidity in this pool\r\n        if (error.isInsufficientReservesError) {\r\n          continue\r\n        }\r\n        throw error\r\n      }\r\n      // we have arrived at the input token, so this is the first trade of one of the paths\r\n      if (currencyEquals(amountIn.currency, tokenIn)) {\r\n        sortedInsert(\r\n          bestTrades,\r\n          await Trade.fromRoute(\r\n            new Route([pool, ...currentPools], currencyIn, currencyAmountOut.currency),\r\n            currencyAmountOut,\r\n            TradeType.EXACT_OUTPUT\r\n          ),\r\n          maxNumResults,\r\n          tradeComparator\r\n        )\r\n      } else if (maxHops > 1 && pools.length > 1) {\r\n        const poolsExcludingThisPool = pools.slice(0, i).concat(pools.slice(i + 1, pools.length))\r\n\r\n        // otherwise, consider all the other paths that arrive at this token as long as we have not exceeded maxHops\r\n        await Trade.bestTradeExactOut(\r\n          poolsExcludingThisPool,\r\n          currencyIn,\r\n          currencyAmountOut,\r\n          {\r\n            maxNumResults,\r\n            maxHops: maxHops - 1\r\n          },\r\n          [pool, ...currentPools],\r\n          amountIn,\r\n          bestTrades\r\n        )\r\n      }\r\n    }\r\n\r\n    return bestTrades\r\n  }\r\n}\r\n","import { BigintIsh, Token } from '@uniswap/sdk-core'\nimport { Interface } from '@ethersproject/abi'\nimport { abi } from '@uniswap/v3-periphery/artifacts/contracts/interfaces/ISelfPermit.sol/ISelfPermit.json'\nimport { toHex } from './utils'\n\nexport interface StandardPermitArguments {\n  v: 0 | 1 | 27 | 28\n  r: string\n  s: string\n  amount: BigintIsh\n  deadline: BigintIsh\n}\n\nexport interface AllowedPermitArguments {\n  v: 0 | 1 | 27 | 28\n  r: string\n  s: string\n  nonce: BigintIsh\n  expiry: BigintIsh\n}\n\nexport type PermitOptions = StandardPermitArguments | AllowedPermitArguments\n\n// type guard\nfunction isAllowedPermit(permitOptions: PermitOptions): permitOptions is AllowedPermitArguments {\n  return 'nonce' in permitOptions\n}\n\nexport abstract class SelfPermit {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  protected constructor() {}\n\n  protected static encodePermit(token: Token, options: PermitOptions) {\n    return isAllowedPermit(options)\n      ? SelfPermit.INTERFACE.encodeFunctionData('selfPermitAllowed', [\n          token.address,\n          toHex(options.nonce),\n          toHex(options.expiry),\n          options.v,\n          options.r,\n          options.s\n        ])\n      : SelfPermit.INTERFACE.encodeFunctionData('selfPermit', [\n          token.address,\n          toHex(options.amount),\n          toHex(options.deadline),\n          options.v,\n          options.r,\n          options.s\n        ])\n  }\n}\n","import {\n  BigintIsh,\n  ChainId,\n  Percent,\n  Token,\n  CurrencyAmount,\n  validateAndParseAddress,\n  WETH9,\n  Currency\n} from '@uniswap/sdk-core'\nimport JSBI from 'jsbi'\nimport invariant from 'tiny-invariant'\nimport { Position } from './entities/position'\nimport { ONE, ZERO } from './internalConstants'\nimport { MethodParameters, toHex } from './utils/calldata'\nimport { Interface } from '@ethersproject/abi'\nimport { abi } from '@uniswap/v3-periphery/artifacts/contracts/NonfungiblePositionManager.sol/NonfungiblePositionManager.json'\nimport { PermitOptions, SelfPermit } from './selfPermit'\nimport { ADDRESS_ZERO } from './constants'\n\nconst MaxUint128 = toHex(JSBI.subtract(JSBI.exponentiate(JSBI.BigInt(2), JSBI.BigInt(128)), JSBI.BigInt(1)))\n\nexport interface MintSpecificOptions {\n  /**\n   * The account that should receive the minted NFT.\n   */\n  recipient: string\n\n  /**\n   * Creates pool if not initialized before mint.\n   */\n  createPool?: boolean\n}\n\nexport interface IncreaseSpecificOptions {\n  /**\n   * Indicates the ID of the position to increase liquidity for.\n   */\n  tokenId: BigintIsh\n}\n\n/**\n * Options for producing the calldata to add liquidity.\n */\nexport interface CommonAddLiquidityOptions {\n  /**\n   * How much the pool price is allowed to move.\n   */\n  slippageTolerance: Percent\n\n  /**\n   * When the transaction expires, in epoch seconds.\n   */\n  deadline: BigintIsh\n\n  /**\n   * Whether to spend ether. If true, one of the pool tokens must be WETH, by default false\n   */\n  useEther?: boolean\n\n  /**\n   * The optional permit parameters for spending token0\n   */\n  token0Permit?: PermitOptions\n\n  /**\n   * The optional permit parameters for spending token1\n   */\n  token1Permit?: PermitOptions\n}\n\nexport type MintOptions = CommonAddLiquidityOptions & MintSpecificOptions\nexport type IncreaseOptions = CommonAddLiquidityOptions & IncreaseSpecificOptions\n\nexport type AddLiquidityOptions = MintOptions | IncreaseOptions\n\n// type guard\nfunction isMint(options: AddLiquidityOptions): options is MintOptions {\n  return Object.keys(options).some(k => k === 'recipient')\n}\n\nexport interface CollectOptions {\n  /**\n   * Indicates the ID of the position to collect for.\n   */\n  tokenId: BigintIsh\n\n  /**\n   * Expected value of tokensOwed0, including as-of-yet-unaccounted-for fees/liquidity value to be burned\n   */\n  expectedCurrencyOwed0: CurrencyAmount<Currency>\n\n  /**\n   * Expected value of tokensOwed1, including as-of-yet-unaccounted-for fees/liquidity value to be burned\n   */\n  expectedCurrencyOwed1: CurrencyAmount<Currency>\n\n  /**\n   * The account that should receive the tokens.\n   */\n  recipient: string\n}\n\nexport interface NFTPermitOptions {\n  v: 0 | 1 | 27 | 28\n  r: string\n  s: string\n  deadline: BigintIsh\n  spender: string\n}\n\n/**\n * Options for producing the calldata to exit a position.\n */\nexport interface RemoveLiquidityOptions {\n  /**\n   * The ID of the token to exit\n   */\n  tokenId: BigintIsh\n\n  /**\n   * The percentage of position liquidity to exit.\n   */\n  liquidityPercentage: Percent\n\n  /**\n   * How much the pool price is allowed to move.\n   */\n  slippageTolerance: Percent\n\n  /**\n   * When the transaction expires, in epoch seconds.\n   */\n  deadline: BigintIsh\n\n  /**\n   * Whether the NFT should be burned if the entire position is being exited, by default false.\n   */\n  burnToken?: boolean\n\n  /**\n   * The optional permit of the token ID being exited, in case the exit transaction is being sent by an account that does not own the NFT\n   */\n  permit?: NFTPermitOptions\n\n  /**\n   * Parameters to be passed on to collect\n   */\n  collectOptions: Omit<CollectOptions, 'tokenId'>\n}\n\nexport abstract class NonfungiblePositionManager extends SelfPermit {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {\n    super()\n  }\n\n  public static addCallParameters(position: Position, options: AddLiquidityOptions): MethodParameters {\n    invariant(JSBI.greaterThan(position.liquidity, ZERO), 'ZERO_LIQUIDITY')\n\n    const calldatas: string[] = []\n\n    // get amounts\n    const { amount0: amount0Desired, amount1: amount1Desired } = position.mintAmounts\n\n    // adjust for slippage\n    const minimumAmounts = position.mintAmountsWithSlippage(options.slippageTolerance)\n    const amount0Min = toHex(minimumAmounts.amount0)\n    const amount1Min = toHex(minimumAmounts.amount1)\n\n    const deadline = toHex(options.deadline)\n\n    // create pool if needed\n    if (isMint(options) && options.createPool) {\n      calldatas.push(\n        NonfungiblePositionManager.INTERFACE.encodeFunctionData('createAndInitializePoolIfNecessary', [\n          position.pool.token0.address,\n          position.pool.token1.address,\n          position.pool.fee,\n          toHex(position.pool.sqrtRatioX96)\n        ])\n      )\n    }\n\n    // permits if necessary\n    if (options.token0Permit) {\n      calldatas.push(NonfungiblePositionManager.encodePermit(position.pool.token0, options.token0Permit))\n    }\n    if (options.token1Permit) {\n      calldatas.push(NonfungiblePositionManager.encodePermit(position.pool.token1, options.token1Permit))\n    }\n\n    // mint\n    if (isMint(options)) {\n      const recipient: string = validateAndParseAddress(options.recipient)\n\n      calldatas.push(\n        NonfungiblePositionManager.INTERFACE.encodeFunctionData('mint', [\n          {\n            token0: position.pool.token0.address,\n            token1: position.pool.token1.address,\n            fee: position.pool.fee,\n            tickLower: position.tickLower,\n            tickUpper: position.tickUpper,\n            amount0Desired: toHex(amount0Desired),\n            amount1Desired: toHex(amount1Desired),\n            amount0Min,\n            amount1Min,\n            recipient,\n            deadline\n          }\n        ])\n      )\n    } else {\n      // increase\n      calldatas.push(\n        NonfungiblePositionManager.INTERFACE.encodeFunctionData('increaseLiquidity', [\n          {\n            tokenId: toHex(options.tokenId),\n            amount0Desired: toHex(amount0Desired),\n            amount1Desired: toHex(amount1Desired),\n            amount0Min,\n            amount1Min,\n            deadline\n          }\n        ])\n      )\n    }\n\n    let value: string = toHex(0)\n\n    if (options.useEther) {\n      const weth = WETH9[position.pool.chainId as ChainId]\n      invariant(weth && (position.pool.token0.equals(weth) || position.pool.token1.equals(weth)), 'NO_WETH')\n\n      const wethValue = position.pool.token0.equals(weth) ? amount0Desired : amount1Desired\n\n      // we only need to refund if we're actually sending ETH\n      if (JSBI.greaterThan(wethValue, ZERO)) {\n        calldatas.push(NonfungiblePositionManager.INTERFACE.encodeFunctionData('refundETH'))\n      }\n\n      value = toHex(wethValue)\n    }\n\n    return {\n      calldata:\n        calldatas.length === 1\n          ? calldatas[0]\n          : NonfungiblePositionManager.INTERFACE.encodeFunctionData('multicall', [calldatas]),\n      value\n    }\n  }\n\n  private static encodeCollect(options: CollectOptions): string[] {\n    const calldatas: string[] = []\n\n    const tokenId = toHex(options.tokenId)\n\n    const involvesETH = options.expectedCurrencyOwed0.currency.isEther || options.expectedCurrencyOwed1.currency.isEther\n\n    const recipient = validateAndParseAddress(options.recipient)\n\n    // collect\n    calldatas.push(\n      NonfungiblePositionManager.INTERFACE.encodeFunctionData('collect', [\n        {\n          tokenId,\n          recipient: involvesETH ? ADDRESS_ZERO : recipient,\n          amount0Max: MaxUint128,\n          amount1Max: MaxUint128\n        }\n      ])\n    )\n\n    if (involvesETH) {\n      const ethAmount = options.expectedCurrencyOwed0.currency.isEther\n        ? options.expectedCurrencyOwed0.quotient\n        : options.expectedCurrencyOwed1.quotient\n      const token = options.expectedCurrencyOwed0.currency.isEther\n        ? (options.expectedCurrencyOwed1.currency as Token)\n        : (options.expectedCurrencyOwed0.currency as Token)\n      const tokenAmount = options.expectedCurrencyOwed0.currency.isEther\n        ? options.expectedCurrencyOwed1.quotient\n        : options.expectedCurrencyOwed0.quotient\n\n      calldatas.push(\n        NonfungiblePositionManager.INTERFACE.encodeFunctionData('unwrapWETH9', [toHex(ethAmount), recipient])\n      )\n      calldatas.push(\n        NonfungiblePositionManager.INTERFACE.encodeFunctionData('sweepToken', [\n          token.address,\n          toHex(tokenAmount),\n          recipient\n        ])\n      )\n    }\n\n    return calldatas\n  }\n\n  public static collectCallParameters(options: CollectOptions): MethodParameters {\n    const calldatas: string[] = NonfungiblePositionManager.encodeCollect(options)\n\n    return {\n      calldata:\n        calldatas.length === 1\n          ? calldatas[0]\n          : NonfungiblePositionManager.INTERFACE.encodeFunctionData('multicall', [calldatas]),\n      value: toHex(0)\n    }\n  }\n\n  /**\n   * Produces the calldata for completely or partially exiting a position\n   * @param position the position to exit\n   * @param options additional information necessary for generating the calldata\n   */\n  public static removeCallParameters(position: Position, options: RemoveLiquidityOptions): MethodParameters {\n    const calldatas: string[] = []\n\n    const deadline = toHex(options.deadline)\n    const tokenId = toHex(options.tokenId)\n\n    // construct a partial position with a percentage of liquidity\n    const partialPosition = new Position({\n      pool: position.pool,\n      liquidity: options.liquidityPercentage.multiply(position.liquidity).quotient,\n      tickLower: position.tickLower,\n      tickUpper: position.tickUpper\n    })\n    invariant(JSBI.greaterThan(partialPosition.liquidity, ZERO), 'ZERO_LIQUIDITY')\n\n    // slippage-adjusted underlying amounts\n    const { amount0: amount0Min, amount1: amount1Min } = partialPosition.burnAmountsWithSlippage(\n      options.slippageTolerance\n    )\n\n    if (options.permit) {\n      calldatas.push(\n        NonfungiblePositionManager.INTERFACE.encodeFunctionData('permit', [\n          validateAndParseAddress(options.permit.spender),\n          tokenId,\n          toHex(options.permit.deadline),\n          options.permit.v,\n          options.permit.r,\n          options.permit.s\n        ])\n      )\n    }\n\n    // remove liquidity\n    calldatas.push(\n      NonfungiblePositionManager.INTERFACE.encodeFunctionData('decreaseLiquidity', [\n        {\n          tokenId,\n          liquidity: toHex(partialPosition.liquidity),\n          amount0Min: toHex(amount0Min),\n          amount1Min: toHex(amount1Min),\n          deadline\n        }\n      ])\n    )\n\n    const { expectedCurrencyOwed0, expectedCurrencyOwed1, ...rest } = options.collectOptions\n    calldatas.push(\n      ...NonfungiblePositionManager.encodeCollect({\n        tokenId: options.tokenId,\n        // add the underlying value to the expected currency already owed\n        expectedCurrencyOwed0: expectedCurrencyOwed0.add(\n          expectedCurrencyOwed0.currency.isEther\n            ? CurrencyAmount.ether(amount0Min)\n            : CurrencyAmount.fromRawAmount(expectedCurrencyOwed0.currency as Token, amount0Min)\n        ),\n        expectedCurrencyOwed1: expectedCurrencyOwed1.add(\n          expectedCurrencyOwed1.currency.isEther\n            ? CurrencyAmount.ether(amount1Min)\n            : CurrencyAmount.fromRawAmount(expectedCurrencyOwed1.currency as Token, amount1Min)\n        ),\n        ...rest\n      })\n    )\n\n    if (options.liquidityPercentage.equalTo(ONE)) {\n      if (options.burnToken) {\n        calldatas.push(NonfungiblePositionManager.INTERFACE.encodeFunctionData('burn', [tokenId]))\n      }\n    } else {\n      invariant(options.burnToken !== true, 'CANNOT_BURN')\n    }\n\n    return {\n      calldata: NonfungiblePositionManager.INTERFACE.encodeFunctionData('multicall', [calldatas]),\n      value: toHex(0)\n    }\n  }\n}\n","import { Interface } from '@ethersproject/abi'\nimport { BigintIsh, Currency, Percent, TradeType, validateAndParseAddress } from '@uniswap/sdk-core'\nimport invariant from 'tiny-invariant'\nimport { Trade } from './entities/trade'\nimport { ADDRESS_ZERO } from './constants'\nimport { PermitOptions, SelfPermit } from './selfPermit'\nimport { encodeRouteToPath } from './utils'\nimport { MethodParameters, toHex } from './utils/calldata'\nimport { abi } from '@uniswap/v3-periphery/artifacts/contracts/SwapRouter.sol/SwapRouter.json'\n\nexport interface FeeOptions {\n  /**\n   * The percent of the output that will be taken as a fee.\n   */\n  fee: Percent\n\n  /**\n   * The recipient of the fee.\n   */\n  recipient: string\n}\n\n/**\n * Options for producing the arguments to send calls to the router.\n */\nexport interface SwapOptions {\n  /**\n   * How much the execution price is allowed to move unfavorably from the trade execution price.\n   */\n  slippageTolerance: Percent\n\n  /**\n   * The account that should receive the output.\n   */\n  recipient: string\n\n  /**\n   * When the transaction expires, in epoch seconds.\n   */\n  deadline: BigintIsh\n\n  /**\n   * The optional permit parameters for spending the input.\n   */\n  inputTokenPermit?: PermitOptions\n\n  /**\n   * The optional price limit for the trade.\n   */\n  sqrtPriceLimitX96?: BigintIsh\n\n  /**\n   * Optional information for taking a fee on output.\n   */\n  fee?: FeeOptions\n}\n\n/**\n * Represents the Uniswap V2 SwapRouter, and has static methods for helping execute trades.\n */\nexport abstract class SwapRouter extends SelfPermit {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {\n    super()\n  }\n\n  /**\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\n   * @param trade to produce call parameters for\n   * @param options options for the call parameters\n   */\n  public static swapCallParameters(\n    trade: Trade<Currency, Currency, TradeType>,\n    options: SwapOptions\n  ): MethodParameters {\n    const calldatas: string[] = []\n\n    // encode permit if necessary\n    if (options.inputTokenPermit) {\n      invariant(trade.inputAmount.currency.isToken, 'NON_TOKEN_PERMIT')\n      calldatas.push(SwapRouter.encodePermit(trade.inputAmount.currency, options.inputTokenPermit))\n    }\n\n    const recipient: string = validateAndParseAddress(options.recipient)\n\n    const deadline = toHex(options.deadline)\n\n    const amountIn: string = toHex(trade.maximumAmountIn(options.slippageTolerance).quotient)\n    console.log('options.slippageTolerance', options.slippageTolerance.toFixed())\n    const amountOut: string = toHex(trade.minimumAmountOut(options.slippageTolerance).quotient)\n\n    const value: string = trade.inputAmount.currency.isEther ? amountIn : toHex(0)\n\n    // flag for whether the trade is single hop or not\n    const singleHop = trade.route.pools.length === 1\n\n    // flag for whether a refund needs to happen\n    const mustRefund = trade.inputAmount.currency.isEther && trade.tradeType === TradeType.EXACT_OUTPUT\n\n    // flags for whether funds should be send first to the router\n    const outputIsEther = trade.outputAmount.currency.isEther\n    const routerMustCustody = outputIsEther || !!options.fee\n\n    if (singleHop) {\n      if (trade.tradeType === TradeType.EXACT_INPUT) {\n        const exactInputSingleParams = {\n          tokenIn: trade.route.tokenPath[0].address,\n          tokenOut: trade.route.tokenPath[1].address,\n          fee: trade.route.pools[0].fee,\n          recipient: routerMustCustody ? ADDRESS_ZERO : recipient,\n          deadline,\n          amountIn,\n          amountOutMinimum: amountOut,\n          sqrtPriceLimitX96: toHex(options.sqrtPriceLimitX96 ?? 0)\n        }\n\n        calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactInputSingle', [exactInputSingleParams]))\n      } else {\n        const exactOutputSingleParams = {\n          tokenIn: trade.route.tokenPath[0].address,\n          tokenOut: trade.route.tokenPath[1].address,\n          fee: trade.route.pools[0].fee,\n          recipient: routerMustCustody ? ADDRESS_ZERO : recipient,\n          deadline,\n          amountOut,\n          amountInMaximum: amountIn,\n          sqrtPriceLimitX96: toHex(options.sqrtPriceLimitX96 ?? 0)\n        }\n\n        calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactOutputSingle', [exactOutputSingleParams]))\n      }\n    } else {\n      invariant(options.sqrtPriceLimitX96 === undefined, 'MULTIHOP_PRICE_LIMIT')\n\n      const path: string = encodeRouteToPath(trade.route, trade.tradeType === TradeType.EXACT_OUTPUT)\n\n      if (trade.tradeType === TradeType.EXACT_INPUT) {\n        const exactInputParams = {\n          path,\n          recipient: routerMustCustody ? ADDRESS_ZERO : recipient,\n          deadline,\n          amountIn,\n          amountOutMinimum: amountOut\n        }\n\n        calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactInput', [exactInputParams]))\n      } else {\n        const exactOutputParams = {\n          path,\n          recipient: routerMustCustody ? ADDRESS_ZERO : recipient,\n          deadline,\n          amountOut,\n          amountInMaximum: amountIn\n        }\n\n        calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactOutput', [exactOutputParams]))\n      }\n    }\n\n    // refund\n    if (mustRefund) {\n      calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('refundETH'))\n    }\n\n    // unwrap\n    if (routerMustCustody) {\n      if (!!options.fee) {\n        const feeRecipient: string = validateAndParseAddress(options.fee.recipient)\n        const fee = toHex(options.fee.fee.multiply(10_000).quotient)\n\n        if (outputIsEther) {\n          calldatas.push(\n            SwapRouter.INTERFACE.encodeFunctionData('unwrapWETH9WithFee', [amountOut, recipient, fee, feeRecipient])\n          )\n        } else {\n          calldatas.push(\n            SwapRouter.INTERFACE.encodeFunctionData('sweepTokenWithFee', [\n              trade.route.tokenPath[trade.route.tokenPath.length - 1].address,\n              amountOut,\n              recipient,\n              fee,\n              feeRecipient\n            ])\n          )\n        }\n      } else {\n        calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('unwrapWETH9', [amountOut, recipient]))\n      }\n    }\n\n    return {\n      calldata:\n        calldatas.length === 1 ? calldatas[0] : SwapRouter.INTERFACE.encodeFunctionData('multicall', [calldatas]),\n      value\n    }\n  }\n}\n","import invariant from 'tiny-invariant'\nimport { TickMath } from './tickMath'\n\n/**\n * Returns the closest tick that is nearest a given tick and usable for the given tick spacing\n * @param tick the target tick\n * @param tickSpacing the spacing of the pool\n */\nexport function nearestUsableTick(tick: number, tickSpacing: number) {\n  invariant(Number.isInteger(tick) && Number.isInteger(tickSpacing), 'INTEGERS')\n  invariant(tickSpacing > 0, 'TICK_SPACING')\n  invariant(tick >= TickMath.MIN_TICK && tick <= TickMath.MAX_TICK, 'TICK_BOUND')\n  const rounded = Math.round(tick / tickSpacing) * tickSpacing\n  if (rounded < TickMath.MIN_TICK) return rounded + tickSpacing\n  else if (rounded > TickMath.MAX_TICK) return rounded - tickSpacing\n  else return rounded\n}\n"],"names":["FeeAmount","runtime","exports","Op","Object","prototype","hasOwn","hasOwnProperty","$Symbol","Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","define","obj","key","value","defineProperty","enumerable","configurable","writable","err","wrap","innerFn","outerFn","self","tryLocsList","generator","create","Generator","context","Context","_invoke","state","method","arg","Error","undefined","done","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","type","makeInvokeMethod","fn","call","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","this","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","forEach","AsyncIterator","PromiseImpl","previousPromise","callInvokeWithMethodAndArg","resolve","reject","invoke","result","__await","then","unwrapped","error","TypeError","info","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","length","i","doneResult","constructor","displayName","isGeneratorFunction","genFun","ctor","name","mark","setPrototypeOf","__proto__","awrap","async","Promise","iter","toString","keys","object","reverse","pop","skipTempReset","prev","charAt","slice","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","catch","thrown","delegateYield","module","regeneratorRuntime","accidentalStrictMode","Function","ADDRESS_ZERO","POOL_INIT_CODE_HASH","TICK_SPACINGS","LOW","MEDIUM","HIGH","NEGATIVE_ONE","JSBI","BigInt","ZERO","ONE","Q96","exponentiate","Q192","computePoolAddress","factoryAddress","tokenA","tokenB","fee","sortsBefore","getCreate2Address","keccak256","defaultAbiCoder","encode","address","LiquidityMath","addDelta","x","y","lessThan","subtract","multiply","add","FullMath","mulDivRoundingUp","a","b","denominator","product","divide","notEqual","remainder","MaxUint160","multiplyIn256","bitwiseAnd","MaxUint256","SqrtPriceMath","getAmount0Delta","sqrtRatioAX96","sqrtRatioBX96","liquidity","roundUp","greaterThan","numerator1","leftShift","numerator2","getAmount1Delta","getNextSqrtPriceFromInput","sqrtPX96","amountIn","zeroForOne","invariant","getNextSqrtPriceFromAmount0RoundingUp","getNextSqrtPriceFromAmount1RoundingDown","getNextSqrtPriceFromOutput","amountOut","amount","equal","sum","greaterThanOrEqual","quotient","lessThanOrEqual","MAX_FEE","SwapMath","computeSwapStep","sqrtRatioCurrentX96","sqrtRatioTargetX96","amountRemaining","feePips","returnValues","exactIn","amountRemainingLessFee","sqrtRatioNextX96","max","feeAmount","TWO","POWERS_OF_2","map","pow","mostSignificantBit","msb","power","signedRightShift","mulShift","val","mulBy","Q32","TickMath","getSqrtRatioAtTick","tick","MIN_TICK","MAX_TICK","Number","isInteger","absTick","ratio","getTickAtSqrtRatio","sqrtRatioX96","MIN_SQRT_RATIO","MAX_SQRT_RATIO","r","sqrtRatioX128","log_2","f","bitwiseOr","log_sqrt10001","tickLow","toNumber","tickHigh","NoTickDataProvider","getTick","_tick","ERROR_MESSAGE","nextInitializedTickWithinOneWord","_lte","_tickSpacing","isSorted","list","comparator","tickComparator","index","TickList","validateList","ticks","tickSpacing","every","reduce","accumulator","liquidityNet","isBelowSmallest","isAtOrAboveLargest","binarySearch","l","Math","floor","nextInitializedTick","lte","compressed","minimum","maximum","min","toHex","bigintIsh","hex","encodeRouteToPath","route","exactOutput","firstInputToken","currency","chainId","isToken","Token","isEther","WETH9","wrappedCurrency","input","pools","pool","inputToken","path","types","outputToken","token0","equals","token1","pack","encodeSqrtRatioX96","amount1","amount0","numerator","ratioX192","sqrt","maxLiquidityForAmount0Imprecise","intermediate","maxLiquidityForAmount0Precise","maxLiquidityForAmount1","maxLiquidityForAmounts","useFullPrecision","maxLiquidityForAmount0","liquidity0","liquidity1","tickToPrice","baseToken","quoteToken","Price","Tick","liquidityGross","TickListDataProvider","ticksMapped","t","NO_TICK_DATA_PROVIDER_DEFAULT","Pool","tickCurrent","tickCurrentSqrtRatioX96","nextTickSqrtRatioX96","tickDataProvider","Array","isArray","getAddress","involvesToken","token","priceOf","token0Price","token1Price","getOutputAmount","inputAmount","sqrtPriceLimitX96","swap","CurrencyAmount","fromRawAmount","amountCalculated","getInputAmount","outputAmount","amountSpecified","exactInput","amountSpecifiedRemaining","sqrtPriceX96","step","sqrtPriceStartX96","tickNext","initialized","sqrtPriceNextX96","_token0Price","_token1Price","Position","tickLower","tickUpper","ratiosAfterSlippage","slippageTolerance","priceLower","asFraction","Percent","priceUpper","sqrtRatioX96Lower","sqrtRatioX96Upper","mintAmountsWithSlippage","poolLower","poolUpper","positionThatWillBeCreated","fromAmounts","mintAmounts","burnAmountsWithSlippage","fromAmount0","fromAmount1","_token0Amount","_token1Amount","_mintAmounts","Route","output","wrappedInput","tokenPath","entries","currentInputToken","nextToken","_midPrice","price","nextInput","tradeComparator","currencyEquals","equalTo","Trade","tradeType","fromRoute","TradeType","EXACT_INPUT","exactOut","EXACT_OUTPUT","amounts","wrappedCurrencyAmount","fromFractionalAmount","createUncheckedTrade","constructorArguments","minimumAmountOut","console","log","q","Fraction","e","slippageAdjustedAmountOut","invert","maximumAmountIn","slippageAdjustedAmountIn","worstExecutionPrice","bestTradeExactIn","currencyAmountIn","currencyOut","currentPools","nextAmountIn","bestTrades","maxNumResults","maxHops","tokenOut","_context4","isInsufficientInputAmountError","sortedInsert","poolsExcludingThisPool","concat","bestTradeExactOut","currencyIn","currencyAmountOut","nextAmountOut","tokenIn","_context5","isInsufficientReservesError","_executionPrice","_priceImpact","computePriceImpact","midPrice","SelfPermit","encodePermit","options","INTERFACE","encodeFunctionData","nonce","expiry","v","s","deadline","Interface","abi","MaxUint128","isMint","some","k","NonfungiblePositionManager","_SelfPermit","addCallParameters","position","calldatas","amount0Desired","amount1Desired","minimumAmounts","amount0Min","amount1Min","createPool","token0Permit","token1Permit","recipient","validateAndParseAddress","tokenId","useEther","weth","wethValue","calldata","encodeCollect","involvesETH","expectedCurrencyOwed0","expectedCurrencyOwed1","amount0Max","amount1Max","tokenAmount","collectCallParameters","removeCallParameters","partialPosition","liquidityPercentage","permit","spender","collectOptions","rest","ether","burnToken","SwapRouter","swapCallParameters","trade","inputTokenPermit","toFixed","mustRefund","outputIsEther","routerMustCustody","exactInputSingleParams","amountOutMinimum","exactOutputSingleParams","amountInMaximum","feeRecipient","rounded","round","sorted","baseCurrency","quoteCurrency","nextTickPrice"],"mappings":"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"}